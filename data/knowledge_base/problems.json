{
  "bubble_sort_optimization": {
    "id": "bubble_sort_optimization",
    "title": "Optimized Bubble Sort",
    "difficulty": "easy",
    "description": "Implement Bubble Sort algorithm with early termination when the list becomes sorted during a pass. Given an array of integers, return the sorted array using an optimized Bubble Sort that stops if no swaps occur in a pass.",
    "input_format": "An array of integers arr",
    "output_format": "The sorted array",
    "constraints": [
      "1 ≤ arr.length ≤ 10^4",
      "-10^5 ≤ arr[i] ≤ 10^5"
    ],
    "example": {
      "input": "[5, 3, 1, 8, 0]",
      "output": "[0, 1, 3, 5, 8]",
      "explanation": "After first pass: [3,1,5,0,8], swaps occurred. Final pass completes with no swaps, terminating early."
    },
    "solution_approach": "Implement Bubble Sort with a flag to check if any swaps occurred in current pass. If no swaps, array is sorted and we terminate early.",
    "related_concepts": [
      "sorting_algorithm",
      "optimization_technique"
    ],
    "cpp_solution": "\n#include <vector>\n\nvoid bubbleSortOptimized(std::vector<int>& arr) {\n    bool swapped;\n    for (int i = 0; i < arr.size()-1; i++) {\n        swapped = false;\n        for (int j = 0; j < arr.size()-i-1; j++) {\n            if (arr[j] > arr[j+1]) {\n                std::swap(arr[j], arr[j+1]);\n                swapped = true;\n            }\n        }\n        if (!swapped) break;\n    }\n}\n"
  },
  "quick_sort_pivot_impact": {
    "id": "quick_sort_pivot_impact",
    "title": "Quick Sort Pivot Strategies",
    "difficulty": "medium",
    "description": "Compare performance of Quick Sort using three pivot selection strategies: first element, last element, and median-of-three. Implement all three variants and analyze their time complexity for different input cases.",
    "input_format": "An array of integers arr",
    "output_format": "The sorted array using each pivot strategy",
    "constraints": [
      "1 ≤ arr.length ≤ 10^5",
      "-10^9 ≤ arr[i] ≤ 10^9"
    ],
    "example": {
      "input": "[9, 3, 7, 5, 1]",
      "output": "[1, 3, 5, 7, 9] for all variants"
    },
    "solution_approach": "Implement partition functions for each pivot strategy. Median-of-three chooses middle of first/middle/last elements. Compare performance on sorted/reversed/random inputs.",
    "related_concepts": [
      "divide_and_conquer",
      "time_complexity_analysis"
    ],
    "cpp_solution": "\n// Partial implementation for median-of-three\nint medianOfThree(std::vector<int>& arr, int low, int high) {\n    int mid = low + (high-low)/2;\n    if (arr[low] > arr[mid]) std::swap(arr[low], arr[mid]);\n    if (arr[low] > arr[high]) std::swap(arr[low], arr[high]);\n    if (arr[mid] > arr[high]) std::swap(arr[mid], arr[high]);\n    return mid;\n}\n"
  },
  "merge_sort_linked_lists": {
    "id": "merge_sort_linked_lists",
    "title": "In-Place Merge Sort for Linked Lists",
    "difficulty": "medium",
    "description": "Implement Merge Sort specifically for linked lists using O(1) extra space. Given head of a singly linked list, return the head of sorted list using constant space complexity.",
    "input_format": "The head of a linked list",
    "output_format": "The head of sorted linked list",
    "constraints": [
      "0 ≤ nodes ≤ 10^4",
      "-10^5 ≤ Node.val ≤ 10^5"
    ],
    "example": {
      "input": "4 -> 2 -> 1 -> 3",
      "output": "1 -> 2 -> 3 -> 4"
    },
    "solution_approach": "Use slow-fast pointer for splitting list. Merge sorted lists in-place without creating new nodes. Implement recursive merge sort with O(1) space.",
    "related_concepts": [
      "linked_list_manipulation",
      "in_place_algorithm"
    ],
    "cpp_solution": "\nListNode* mergeSort(ListNode* head) {\n    if (!head || !head->next) return head;\n    \n    // Split list\n    ListNode* slow = head;\n    ListNode* fast = head->next;\n    while (fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    ListNode* second = slow->next;\n    slow->next = nullptr;\n    \n    return merge(mergeSort(head), mergeSort(second));\n}\n"
  },
  "counting_sort_negative": {
    "id": "counting_sort_negative",
    "title": "Counting Sort with Negative Numbers",
    "difficulty": "medium",
    "description": "Modify Counting Sort algorithm to handle arrays containing negative integers efficiently. Return sorted array preserving original element values.",
    "input_format": "An array of integers arr",
    "output_format": "Sorted array including negative numbers",
    "constraints": [
      "1 ≤ arr.length ≤ 10^6",
      "-10^4 ≤ arr[i] ≤ 10^4"
    ],
    "example": {
      "input": "[-5, 3, -2, 0, 4]",
      "output": "[-5, -2, 0, 3, 4]"
    },
    "solution_approach": "Shift all values by minimum element to make indices non-negative. Perform counting sort on shifted values, then reverse the shift.",
    "related_concepts": [
      "non_comparison_sort",
      "index_mapping"
    ],
    "cpp_solution": "\nvoid countingSortNegatives(std::vector<int>& arr) {\n    int min_val = *min_element(arr.begin(), arr.end());\n    int max_val = *max_element(arr.begin(), arr.end());\n    int range = max_val - min_val + 1;\n    \n    std::vector<int> count(range), output(arr.size());\n    for (int num : arr) count[num - min_val]++;\n    \n    for (int i = 1; i < range; i++) count[i] += count[i-1];\n    \n    for (int i = arr.size()-1; i >= 0; i--) {\n        output[count[arr[i] - min_val] - 1] = arr[i];\n        count[arr[i] - min_val]--;\n    }\n    \n    arr = output;\n}\n"
  },
  "radix_sort_strings": {
    "id": "radix_sort_strings",
    "title": "Radix Sort for Variable-Length Strings",
    "difficulty": "hard",
    "description": "Adapt Radix Sort to lexicographically sort an array of variable-length ASCII strings. Handle different lengths by considering missing characters as lower than any existing character.",
    "input_format": "An array of strings arr",
    "output_format": "Lexicographically sorted array",
    "constraints": [
      "1 ≤ arr.length ≤ 10^5",
      "1 ≤ string length ≤ 100",
      "All characters are printable ASCII"
    ],
    "example": {
      "input": "[\"apple\", \"banana\", \"app\", \"cat\"]",
      "output": "[\"app\", \"apple\", \"banana\", \"cat\"]"
    },
    "solution_approach": "Sort from least to most significant character using counting sort. Pad shorter strings with placeholder values. Handle variable lengths by checking character existence.",
    "related_concepts": [
      "lexicographical_order",
      "string_manipulation"
    ],
    "cpp_solution": "\nvoid radixSortStrings(std::vector<std::string>& arr) {\n    int max_len = 0;\n    for (auto& s : arr) max_len = std::max(max_len, (int)s.length());\n    \n    for (int pos = max_len-1; pos >= 0; pos--) {\n        std::vector<std::string> output(arr.size());\n        std::vector<int> count(256, 0);\n        \n        for (auto& s : arr) {\n            int c = (pos < s.length()) ? s[pos] : 0;\n            count[c]++;\n        }\n        \n        for (int i = 1; i < 256; i++) count[i] += count[i-1];\n        \n        for (int i = arr.size()-1; i >= 0; i--) {\n            int c = (pos < arr[i].length()) ? arr[i][pos] : 0;\n            output[count[c]-1] = arr[i];\n            count[c]--;\n        }\n        \n        arr = output;\n    }\n}\n"
  },
  "heap_vs_quick_nearly_sorted": {
      "id": "heap_vs_quick_nearly_sorted",
      "title": "Heap Sort vs Quick Sort on Nearly Sorted Data",
      "difficulty": "medium",
      "description": "Compare performance of Heap Sort and Quick Sort when sorting nearly sorted arrays. Return sorted array using both algorithms and analyze their time complexity.",
      "input_format": "A nearly sorted array of integers arr",
      "output_format": "Sorted array using both algorithms",
      "constraints": [
        "1 ≤ arr.length ≤ 10^5",
        "-10^9 ≤ arr[i] ≤ 10^9"
      ],
      "example": {
        "input": "[1, 3, 2, 4, 6, 5, 7, 9, 8]",
        "output": "[1,2,3,4,5,6,7,8,9] for both",
        "explanation": "Heap Sort maintains O(n log n) time while Quick Sort may degrade to O(n²) with poor pivot choices"
      },
      "solution_approach": "Heap Sort's guaranteed O(n log n) vs Quick Sort's O(n²) worst-case. Use median-of-three pivot for better Quick Sort performance.",
      "related_concepts": [
        "comparison_sort",
        "time_complexity_analysis"
      ],
      "cpp_solution": "\n// Heap Sort implementation\nvoid heapSort(std::vector<int>& arr) {\n    std::make_heap(arr.begin(), arr.end());\n    std::sort_heap(arr.begin(), arr.end());\n}\n\n// Quick Sort with median-of-three\nvoid quickSort(std::vector<int>& arr, int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi-1);\n        quickSort(arr, pi+1, high);\n    }\n}\n"
    },
    "dutch_flag_sort": {
      "id": "dutch_flag_sort",
      "title": "Sort Colors (Dutch National Flag)",
      "difficulty": "medium",
      "description": "Implement three-way partitioning to sort an array of 0s, 1s, and 2s in O(n) time with O(1) space complexity.",
      "input_format": "An array of integers arr where arr[i] ∈ {0,1,2}",
      "output_format": "Sorted array",
      "constraints": [
        "1 ≤ arr.length ≤ 10^5",
        "0 ≤ arr[i] ≤ 2"
      ],
      "example": {
        "input": "[2,0,1,2,1,0]",
        "output": "[0,0,1,1,2,2]"
      },
      "solution_approach": "Use three pointers: low (0 boundary), mid (1 boundary), high (2 boundary). Swap elements based on current mid value.",
      "related_concepts": [
        "two_pointer_technique",
        "in_place_algorithm"
      ],
      "cpp_solution": "\nvoid sortColors(std::vector<int>& nums) {\n    int low = 0, mid = 0, high = nums.size()-1;\n    while (mid <= high) {\n        switch(nums[mid]) {\n            case 0: std::swap(nums[low++], nums[mid++]); break;\n            case 1: mid++; break;\n            case 2: std::swap(nums[mid], nums[high--]); break;\n        }\n    }\n}\n"
    },
    "merge_k_sorted": {
      "id": "merge_k_sorted",
      "title": "Merge k Sorted Arrays",
      "difficulty": "hard",
      "description": "Merge k sorted arrays into one sorted array efficiently using min-heap/priority queue approach.",
      "input_format": "A list of k sorted arrays",
      "output_format": "Single sorted array containing all elements",
      "constraints": [
        "1 ≤ k ≤ 1000",
        "0 ≤ individual array length ≤ 500",
        "-10^5 ≤ elements ≤ 10^5"
      ],
      "example": {
        "input": "[[1,4,5],[1,3,4],[2,6]]",
        "output": "[1,1,2,3,4,4,5,6]"
      },
      "solution_approach": "Use min-heap to track smallest elements from each array. Pop smallest and push next element from source array.",
      "related_concepts": [
        "priority_queue",
        "divide_and_conquer"
      ],
      "cpp_solution": "\nstruct Node {\n    int val, arr_idx, elem_idx;\n    bool operator>(const Node& other) const { return val > other.val; }\n};\n\nstd::vector<int> mergeKSorted(std::vector<std::vector<int>>& arrays) {\n    std::priority_queue<Node, std::vector<Node>, std::greater<Node>> pq;\n    \n    for (int i = 0; i < arrays.size(); i++) {\n        if (!arrays[i].empty()) pq.push({arrays[i][0], i, 0});\n    }\n    \n    std::vector<int> result;\n    while (!pq.empty()) {\n        auto node = pq.top(); pq.pop();\n        result.push_back(node.val);\n        \n        if (node.elem_idx+1 < arrays[node.arr_idx].size()) {\n            pq.push({arrays[node.arr_idx][node.elem_idx+1], node.arr_idx, node.elem_idx+1});\n        }\n    }\n    return result;\n}\n"
    },
    "wiggle_sort": {
      "id": "wiggle_sort",
      "title": "Wiggle Sort II",
      "difficulty": "medium",
      "description": "Arrange elements in nums such that nums[0] < nums[1] > nums[2] < nums[3] > ...",
      "input_format": "An array of integers arr",
      "output_format": "Wiggle-sorted array",
      "constraints": [
        "1 ≤ arr.length ≤ 5*10^4",
        "0 ≤ arr[i] ≤ 5000"
      ],
      "example": {
        "input": "[1,5,1,1,6,4]",
        "output": "[1,6,1,5,1,4]"
      },
      "solution_approach": "Sort array and swap elements starting from second position. For O(n) time, use median partitioning and virtual indexing.",
      "related_concepts": [
        "array_manipulation",
        "greedy_algorithm"
      ],
      "cpp_solution": "\nvoid wiggleSort(std::vector<int>& nums) {\n    std::vector<int> sorted(nums);\n    std::sort(sorted.begin(), sorted.end());\n    \n    int n = nums.size();\n    int i = (n-1)/2, j = n-1;\n    \n    for (int k = 0; k < n; k++) {\n        nums[k] = (k%2 == 0) ? sorted[i--] : sorted[j--];\n    }\n}\n"
    },
    "sort_characters_by_frequency": {
      "id": "sort_characters_by_frequency",
      "title": "Sort Characters by Frequency",
      "difficulty": "medium",
      "description": "Given a string, sort it in decreasing order based on character frequencies. If same frequency, maintain original order.",
      "input_format": "A string s",
      "output_format": "Sorted string by character frequency",
      "constraints": [
        "1 ≤ s.length ≤ 10^5",
        "s contains printable ASCII characters"
      ],
      "example": {
        "input": "\"tree\"",
        "output": "\"eetr\" or \"eert\""
      },
      "solution_approach": "Use frequency map with bucket sort. Create array of buckets where index represents frequency.",
      "related_concepts": [
        "hash_map",
        "bucket_sort"
      ],
      "cpp_solution": "\nstd::string frequencySort(std::string s) {\n    std::unordered_map<char, int> freq;\n    for (char c : s) freq[c]++;\n    \n    std::vector<std::string> buckets(s.size()+1, \"\");\n    for (auto& [c, count] : freq) {\n        buckets[count] += std::string(count, c);\n    }\n    \n    std::string result;\n    for (int i = buckets.size()-1; i >= 0; i--) {\n        if (!buckets[i].empty()) result += buckets[i];\n    }\n    return result;\n}\n"
    },
  "maximum_gap": {
        "id": "maximum_gap",
        "title": "Maximum Gap (Bucket Sort)",
        "difficulty": "hard",
        "description": "Find maximum difference between successive elements in sorted array using linear time/space bucket sort approach.",
        "input_format": "An array of integers nums",
        "output_format": "Maximum gap between successive elements",
        "constraints": [
          "1 ≤ nums.length ≤ 10^5",
          "0 ≤ nums[i] ≤ 10^9"
        ],
        "example": {
          "input": "[3,6,9,1]",
          "output": "3",
          "explanation": "Sorted array [1,3,6,9] has maximum gap 3 between 3-6 or 6-9"
        },
        "solution_approach": "Bucket Sort with min/max tracking per bucket. Maximum gap exists between adjacent buckets' min/max values.",
        "related_concepts": [
          "bucket_sort",
          "linear_time_sorting"
        ],
        "cpp_solution": "\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint maximumGap(vector<int>& nums) {\n    int n = nums.size();\n    if(n < 2) return 0;\n    \n    int mi = *min_element(nums.begin(), nums.end());\n    int mx = *max_element(nums.begin(), nums.end());\n    \n    int bucket_size = max(1, (mx - mi)/(n - 1));\n    int bucket_count = (mx - mi)/bucket_size + 1;\n    \n    vector<pair<int, int>> buckets(bucket_count, {INT_MAX, INT_MIN});\n    for(int v : nums) {\n        int idx = (v - mi)/bucket_size;\n        buckets[idx].first = min(buckets[idx].first, v);\n        buckets[idx].second = max(buckets[idx].second, v);\n    }\n    \n    int max_gap = 0, prev = mi;\n    for(auto& [cur_min, cur_max] : buckets) {\n        if(cur_min == INT_MAX) continue;\n        max_gap = max(max_gap, cur_min - prev);\n        prev = cur_max;\n    }\n    return max_gap;\n}\n"
      },
      "custom_sort_string": {
        "id": "custom_sort_string",
        "title": "Custom Sort String",
        "difficulty": "medium",
        "description": "Sort string 's' characters in the order specified by string 'order'. Preserve original order for characters not in 'order'.",
        "input_format": "Two strings order and s",
        "output_format": "Custom sorted string",
        "constraints": [
          "1 ≤ order.length ≤ 26",
          "1 ≤ s.length ≤ 200",
          "All characters in order and s are lowercase letters"
        ],
        "example": {
          "input": "\"cba\" \"abcd\"",
          "output": "\"cbad\"",
          "explanation": "'c' comes first, then 'b', 'a', followed by 'd'"
        },
        "solution_approach": "Counting sort with custom priority. Build frequency map of 's', then construct result following 'order' sequence.",
        "related_concepts": [
          "counting_sort",
          "string_manipulation"
        ],
        "cpp_solution": "\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring customSortString(string order, string s) {\n    vector<int> count(26, 0);\n    for(char c : s) count[c - 'a']++;\n    \n    string res;\n    for(char c : order) {\n        res += string(count[c - 'a'], c);\n        count[c - 'a'] = 0;\n    }\n    \n    for(int i = 0; i < 26; i++)\n        res += string(count[i], 'a' + i);\n    return res;\n}\n"
      },
      "sort_transformed_array": {
        "id": "sort_transformed_array",
        "title": "Sort Transformed Array",
        "difficulty": "medium",
        "description": "Given sorted array nums, apply quadratic transformation f(x) = ax² + bx + c and return sorted result in O(n) time.",
        "input_format": "Sorted array nums, integers a, b, c",
        "output_format": "Sorted transformed array",
        "constraints": [
          "1 ≤ nums.length ≤ 10^5",
          "-10^9 ≤ nums[i] ≤ 10^9"
        ],
        "example": {
          "input": "nums = [-4,-2,2,4], a = 1, b = 3, c = 5",
          "output": "[3,9,15,33]",
          "explanation": "f(-4)=33, f(-2)=15, f(2)=15, f(4)=33 → sorted [3,9,15,33]"
        },
        "solution_approach": "Two pointers from ends based on parabola direction. Merge values in ascending/descending order based on coefficient 'a'.",
        "related_concepts": [
          "two_pointers",
          "mathematical_optimization"
        ],
        "cpp_solution": "\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sortTransformedArray(vector<int>& nums, int a, int b, int c) {\n    int n = nums.size();\n    vector<int> res(n);\n    int left = 0, right = n-1;\n    \n    auto f = [&](int x){ return a*x*x + b*x + c; };\n    int idx = a > 0 ? n-1 : 0;\n    \n    while(left <= right) {\n        int fl = f(nums[left]);\n        int fr = f(nums[right]);\n        \n        if(a > 0) {\n            res[idx--] = fl > fr ? fl : fr;\n            fl > fr ? left++ : right--;\n        } else {\n            res[idx++] = fl < fr ? fl : fr;\n            fl < fr ? left++ : right--;\n        }\n    }\n    return res;\n}\n"
      },
      "h_index": {
        "id": "h_index",
        "title": "H-Index Counting Sort",
        "difficulty": "medium",
        "description": "Compute researcher's h-index using counting sort. h-index is the maximum value where at least h papers have ≥ h citations.",
        "input_format": "Array of integers citations",
        "output_format": "Integer h-index",
        "constraints": [
          "1 ≤ citations.length ≤ 5000",
          "0 ≤ citations[i] ≤ 1000"
        ],
        "example": {
          "input": "[3,0,6,1,5]",
          "output": "3",
          "explanation": "3 papers have ≥3 citations (6,5,3)"
        },
        "solution_approach": "Create frequency array for citations. Find largest index where cumulative count ≥ index.",
        "related_concepts": [
          "counting_sort",
          "research_metrics"
        ],
        "cpp_solution": "\n#include <vector>\n\nusing namespace std;\n\nint hIndex(vector<int>& citations) {\n    int n = citations.size();\n    vector<int> count(n+2, 0);\n    \n    for(int c : citations)\n        count[min(c, n)]++;\n    \n    int total = 0;\n    for(int i = n; i >= 0; i--) {\n        total += count[i];\n        if(total >= i) return i;\n    }\n    return 0;\n}\n"
      },
      "sort_linked_list": {
        "id": "sort_linked_list",
        "title": "Sort Linked List (O(1) Space)",
        "difficulty": "medium",
        "description": "Sort linked list in O(n log n) time with O(1) space using iterative merge sort.",
        "input_format": "Head of singly linked list",
        "output_format": "Head of sorted linked list",
        "constraints": [
          "0 ≤ nodes ≤ 5*10^4",
          "-10^5 ≤ Node.val ≤ 10^5"
        ],
        "example": {
          "input": "4->2->1->3",
          "output": "1->2->3->4"
        },
        "solution_approach": "Iterative merge sort with bottom-up approach. Merge sublists of increasing sizes (1,2,4...).",
        "related_concepts": [
          "linked_list",
          "iterative_merge_sort"
        ],
        "cpp_solution": "\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        if(!head || !head->next) return head;\n        \n        int len = 0;\n        ListNode* curr = head;\n        while(curr) { len++; curr = curr->next; }\n        \n        ListNode dummy(0);\n        dummy.next = head;\n        \n        for(int sz = 1; sz < len; sz <<= 1) {\n            ListNode* tail = &dummy;\n            ListNode* left = dummy.next;\n            \n            while(left) {\n                ListNode* right = split(left, sz);\n                ListNode* next = split(right, sz);\n                tail = merge(left, right, tail);\n                left = next;\n            }\n        }\n        return dummy.next;\n    }\n    \nprivate:\n    ListNode* split(ListNode* head, int n) {\n        while(--n && head) head = head->next;\n        ListNode* rest = head ? head->next : nullptr;\n        if(head) head->next = nullptr;\n        return rest;\n    }\n    \n    ListNode* merge(ListNode* l1, ListNode* l2, ListNode* tail) {\n        while(l1 && l2) {\n            if(l1->val < l2->val) {\n                tail->next = l1;\n                l1 = l1->next;\n            } else {\n                tail->next = l2;\n                l2 = l2->next;\n            }\n            tail = tail->next;\n        }\n        tail->next = l1 ? l1 : l2;\n        while(tail->next) tail = tail->next;\n        return tail;\n    }\n};\n"
  },
  "first_last_position_sorted": {
      "id": "first_last_position_sorted",
      "title": "First/Last Position in Sorted Array",
      "difficulty": "medium",
      "description": "Given a sorted array of integers, find the first and last positions of a target value using binary search. Return [-1, -1] if not found.",
      "input_format": "An array of integers nums and integer target",
      "output_format": "Array with start and end indices of target",
      "constraints": [
        "0 ≤ nums.length ≤ 10^5",
        "-10^9 ≤ nums[i] ≤ 10^9"
      ],
      "example": {
        "input": "nums = [5,7,7,8,8,10], target = 8",
        "output": "[3,4]",
        "explanation": "8 appears at indices 3 and 4"
      },
      "solution_approach": "Perform two binary searches: first occurrence (leftmost) and last occurrence (rightmost). Compare mid values to adjust search boundaries.",
      "related_concepts": [
        "binary_search",
        "array_manipulation"
      ],
      "cpp_solution": "\n#include <vector>\n\nusing namespace std;\n\nvector<int> searchRange(vector<int>& nums, int target) {\n    int first = -1, last = -1;\n    int low = 0, high = nums.size()-1;\n    \n    // Find first occurrence\n    while(low <= high) {\n        int mid = low + (high-low)/2;\n        if(nums[mid] >= target) high = mid-1;\n        else low = mid+1;\n        if(nums[mid] == target) first = mid;\n    }\n    \n    // Find last occurrence\n    low = 0, high = nums.size()-1;\n    while(low <= high) {\n        int mid = low + (high-low)/2;\n        if(nums[mid] <= target) low = mid+1;\n        else high = mid-1;\n        if(nums[mid] == target) last = mid;\n    }\n    \n    return {first, last};\n}\n"
    },
    "search_rotated_sorted": {
      "id": "search_rotated_sorted",
      "title": "Search in Rotated Sorted Array",
      "difficulty": "medium",
      "description": "Given a rotated sorted array, find the index of target using modified binary search. Return -1 if not found.",
      "input_format": "An array of integers nums and integer target",
      "output_format": "Integer index of target",
      "constraints": [
        "1 ≤ nums.length ≤ 5000",
        "-10^4 ≤ nums[i] ≤ 10^4"
      ],
      "example": {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": "Target 0 is at index 4 in rotated array"
      },
      "solution_approach": "Identify sorted half of array. Check if target lies within sorted half to adjust search boundaries.",
      "related_concepts": [
        "rotated_array",
        "binary_search_variation"
      ],
      "cpp_solution": "\nint searchRotated(vector<int>& nums, int target) {\n    int low = 0, high = nums.size()-1;\n    \n    while(low <= high) {\n        int mid = low + (high-low)/2;\n        if(nums[mid] == target) return mid;\n        \n        if(nums[low] <= nums[mid]) { // Left half sorted\n            if(target >= nums[low] && target < nums[mid]) high = mid-1;\n            else low = mid+1;\n        } else { // Right half sorted\n            if(target > nums[mid] && target <= nums[high]) low = mid+1;\n            else high = mid-1;\n        }\n    }\n    return -1;\n}\n"
    },
    "find_peak_element": {
      "id": "find_peak_element",
      "title": "Find Peak Element",
      "difficulty": "medium",
      "description": "Find any peak element in an array where nums[i] ≠ nums[i+1] using binary search. A peak is greater than its neighbors.",
      "input_format": "An array of integers nums",
      "output_format": "Index of any peak element",
      "constraints": [
        "1 ≤ nums.length ≤ 1000",
        "-2^31 ≤ nums[i] ≤ 2^31 - 1"
      ],
      "example": {
        "input": "[1,2,3,1]",
        "output": "2",
        "explanation": "Element 3 at index 2 is a peak"
      },
      "solution_approach": "Binary search comparing mid with mid+1. Move towards the rising slope to find peak.",
      "related_concepts": [
        "binary_search",
        "mountain_array"
      ],
      "cpp_solution": "\nint findPeakElement(vector<int>& nums) {\n    int low = 0, high = nums.size()-1;\n    \n    while(low < high) {\n        int mid = low + (high-low)/2;\n        if(nums[mid] < nums[mid+1]) low = mid+1;\n        else high = mid;\n    }\n    return low;\n}\n"
    },
    "interpolation_search_app": {
      "id": "interpolation_search_app",
      "title": "Interpolation Search Applications",
      "difficulty": "hard",
      "description": "Implement interpolation search for uniformly distributed sorted arrays. Explain when it outperforms binary search.",
      "input_format": "Sorted array nums and integer target",
      "output_format": "Index of target or -1",
      "constraints": [
        "1 ≤ nums.length ≤ 10^6",
        "-10^9 ≤ nums[i] ≤ 10^9"
      ],
      "example": {
        "input": "nums = [10,20,30,40,50], target = 40",
        "output": "3",
        "explanation": "Interpolation search finds position directly"
      },
      "solution_approach": "Calculate probe position using formula: pos = low + ((target - arr[low])*(high-low))/(arr[high]-arr[low])",
      "related_concepts": [
        "uniform_distribution",
        "search_optimization"
      ],
      "cpp_solution": "\nint interpolationSearch(vector<int>& nums, int target) {\n    int low = 0, high = nums.size()-1;\n    \n    while(low <= high && target >= nums[low] && target <= nums[high]) {\n        int pos = low + ((target - nums[low]) * (high - low)) / (nums[high] - nums[low]);\n        \n        if(nums[pos] == target) return pos;\n        if(nums[pos] < target) low = pos + 1;\n        else high = pos - 1;\n    }\n    return -1;\n}\n"
    },
    "sqrt_precision": {
      "id": "sqrt_precision",
      "title": "Square Root with Precision",
      "difficulty": "medium",
      "description": "Compute square root of a number with given precision using binary search. Return result rounded to specified decimal places.",
      "input_format": "Integer n and precision value",
      "output_format": "Floating point square root",
      "constraints": [
        "0 ≤ n ≤ 10^9",
        "0.0001 ≤ precision ≤ 0.1"
      ],
      "example": {
        "input": "n = 5, precision = 0.001",
        "output": "2.236",
        "explanation": "√5 ≈ 2.236 with 0.001 precision"
      },
      "solution_approach": "Binary search between 0 and n. Compare mid^2 with n. Continue until difference < precision.",
      "related_concepts": [
        "binary_search",
        "numerical_methods"
      ],
      "cpp_solution": "\ndouble sqrtPrecision(int n, double precision) {\n    double low = 0, high = n, ans;\n    \n    while(high - low > precision) {\n        double mid = low + (high - low)/2;\n        if(mid*mid == n) return mid;\n        \n        if(mid*mid < n) {\n            low = mid;\n            ans = mid;\n        } else {\n            high = mid;\n        }\n    }\n    return round(ans/precision)*precision;\n}\n"
    },
  "kth_smallest_matrix": {
        "id": "kth_smallest_matrix",
        "title": "Kth Smallest Element in Sorted Matrix",
        "difficulty": "medium",
        "description": "Find the kth smallest element in an n x n matrix where each row and column is sorted in non-decreasing order. Use binary search on value range.",
        "input_format": "2D matrix and integer k",
        "output_format": "Integer kth smallest element",
        "constraints": [
          "n == matrix.length == matrix[i].length",
          "1 ≤ n ≤ 300",
          "1 ≤ k ≤ n²"
        ],
        "example": {
          "input": "[[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "output": "13",
          "explanation": "8th smallest element is 13"
        },
        "solution_approach": "Binary search between matrix[0][0] and matrix[n-1][n-1]. For each mid value, count elements ≤ mid using matrix traversal optimization.",
        "related_concepts": [
          "binary_search",
          "matrix_traversal"
        ],
        "cpp_solution": "\nint kthSmallest(vector<vector<int>>& matrix, int k) {\n    int n = matrix.size();\n    int low = matrix[0][0], high = matrix[n-1][n-1];\n    \n    while(low < high) {\n        int mid = low + (high-low)/2;\n        int count = 0, j = n-1;\n        \n        for(int i=0; i<n; i++) {\n            while(j >=0 && matrix[i][j] > mid) j--;\n            count += (j+1);\n        }\n        \n        if(count < k) low = mid+1;\n        else high = mid;\n    }\n    return low;\n}\n"
      },
      "random_pick_weight": {
        "id": "random_pick_weight",
        "title": "Random Pick with Weight",
        "difficulty": "medium",
        "description": "Implement a weighted random pick where index i has probability w[i]/sum(w). Use prefix sum and binary search.",
        "input_format": "Array of weights w[]",
        "output_format": "Random index according to weights",
        "constraints": [
          "1 ≤ w.length ≤ 10^4",
          "1 ≤ w[i] ≤ 10^5"
        ],
        "example": {
          "input": "[1,3]",
          "output": "1 (75% probability)",
          "explanation": "Index 1 appears 3/4 times"
        },
        "solution_approach": "Create prefix sum array. Generate random number in [1, total] and find first prefix ≥ random using binary search.",
        "related_concepts": [
          "prefix_sum",
          "probability"
        ],
        "cpp_solution": "\nclass Solution {\n    vector<int> prefix;\npublic:\n    Solution(vector<int>& w) {\n        partial_sum(w.begin(), w.end(), back_inserter(prefix));\n    }\n    \n    int pickIndex() {\n        int rand_num = rand() % prefix.back() +1;\n        return upper_bound(prefix.begin(), prefix.end(), rand_num-1) - prefix.begin();\n    }\n};\n"
      },
      "min_rotated_array": {
        "id": "min_rotated_array",
        "title": "Find Minimum in Rotated Sorted Array",
        "difficulty": "medium",
        "description": "Find the minimum element in a sorted array rotated between 1 and n times. Optimize with binary search.",
        "input_format": "Rotated sorted array nums[]",
        "output_format": "Minimum element",
        "constraints": [
          "1 ≤ nums.length ≤ 5000",
          "-5000 ≤ nums[i] ≤ 5000"
        ],
        "example": {
          "input": "[3,4,5,1,2]",
          "output": "1",
          "explanation": "Array was rotated 3 times"
        },
        "solution_approach": "Binary search comparing mid with right element. Adjust search boundaries based on which half is sorted.",
        "related_concepts": [
          "rotated_array",
          "binary_search"
        ],
        "cpp_solution": "\nint findMin(vector<int>& nums) {\n    int low=0, high=nums.size()-1;\n    while(low < high) {\n        int mid = low + (high-low)/2;\n        if(nums[mid] > nums[high]) low = mid+1;\n        else high = mid;\n    }\n    return nums[low];\n}\n"
      },
      "search_2d_matrix_ii": {
        "id": "search_2d_matrix_ii",
        "title": "Search in 2D Matrix II",
        "difficulty": "medium",
        "description": "Search for a target in an m x n matrix sorted row-wise and column-wise. Optimize with O(m+n) traversal.",
        "input_format": "2D matrix and integer target",
        "output_format": "Boolean indicating existence",
        "constraints": [
          "m == matrix.length",
          "n == matrix[i].length",
          "1 ≤ m, n ≤ 300"
        ],
        "example": {
          "input": "[[1,4,7],[2,5,8],[3,6,9]], target=5",
          "output": "true",
          "explanation": "5 exists in the matrix"
        },
        "solution_approach": "Start from top-right corner. Move left if current > target, down if current < target.",
        "related_concepts": [
          "matrix_traversal",
          "two_pointers"
        ],
        "cpp_solution": "\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\n    int row=0, col=matrix[0].size()-1;\n    \n    while(row < matrix.size() && col >=0) {\n        if(matrix[row][col] == target) return true;\n        matrix[row][col] > target ? col-- : row++;\n    }\n    return false;\n}\n"
      },
      "max_candies_allocation": {
        "id": "max_candies_allocation",
        "title": "Maximum Candies Allocated to K Children",
        "difficulty": "hard",
        "description": "Distribute candy piles to k children with maximum candies per child. Use binary search on possible values.",
        "input_format": "Array of candy piles and integer k",
        "output_format": "Maximum candies per child",
        "constraints": [
          "1 ≤ candies.length ≤ 10^5",
          "1 ≤ candies[i] ≤ 10^7",
          "1 ≤ k ≤ 10^12"
        ],
        "example": {
          "input": "[5,8,6], k=3",
          "output": "5",
          "explanation": "5+8/1+6/1 → 3 children get ≥5 candies"
        },
        "solution_approach": "Binary search between 1 and max(candies). For each mid, check if sum(piles/mid) ≥ k.",
        "related_concepts": [
          "binary_search",
          "greedy_algorithm"
        ],
        "cpp_solution": "\nint maximumCandies(vector<int>& candies, long long k) {\n    long long left=1, right=*max_element(candies.begin(), candies.end());\n    int ans=0;\n    \n    while(left <= right) {\n        long long mid = left + (right-left)/2;\n        long long total=0;\n        \n        for(int c : candies) {\n            total += c/mid;\n            if(total >= k) break;\n        }\n        \n        if(total >= k) {\n            ans = mid;\n            left = mid+1;\n        } else {\n            right = mid-1;\n        }\n    }\n    return ans;\n}\n"
  },
  "number_of_islands": {
      "id": "number_of_islands",
      "title": "Number of Islands",
      "difficulty": "medium",
      "description": "Given a 2D grid of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and formed by connecting adjacent lands horizontally or vertically.",
      "input_format": "2D character grid",
      "output_format": "Integer count of islands",
      "constraints": [
        "m == grid.length",
        "n == grid[i].length",
        "1 ≤ m, n ≤ 300",
        "grid[i][j] is '0' or '1'"
      ],
      "example": {
        "input": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
        "output": "3",
        "explanation": "Three separate islands exist in the grid"
      },
      "solution_approach": "Use BFS/DFS to traverse and mark all connected land cells. Increment count for each unvisited land cell found.",
      "related_concepts": [
        "bfs",
        "dfs",
        "grid_traversal"
      ],
      "cpp_solution": "\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint numIslands(vector<vector<char>>& grid) {\n    int m = grid.size(), n = grid[0].size(), islands = 0;\n    vector<pair<int,int>> dirs = {{-1,0},{1,0},{0,-1},{0,1}};\n    \n    for(int i=0; i<m; i++) {\n        for(int j=0; j<n; j++) {\n            if(grid[i][j] == '1') {\n                islands++;\n                queue<pair<int,int>> q;\n                q.push({i,j});\n                grid[i][j] = '0';\n                while(!q.empty()) {\n                    auto [x,y] = q.front(); q.pop();\n                    for(auto [dx,dy] : dirs) {\n                        int nx = x+dx, ny = y+dy;\n                        if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]=='1') {\n                            grid[nx][ny] = '0';\n                            q.push({nx,ny});\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return islands;\n}\n"
    },
    "course_schedule": {
      "id": "course_schedule",
      "title": "Course Schedule",
      "difficulty": "medium",
      "description": "Determine if it's possible to finish all courses given prerequisites as pairs [a,b] where b must be taken before a.",
      "input_format": "Integer numCourses and list of prerequisite pairs",
      "output_format": "Boolean indicating possibility",
      "constraints": [
        "1 ≤ numCourses ≤ 10^5",
        "0 ≤ prerequisites.length ≤ 5000",
        "prerequisites[i].length == 2"
      ],
      "example": {
        "input": "numCourses = 2, prerequisites = [[1,0]]",
        "output": "true",
        "explanation": "Take 0 then 1"
      },
      "solution_approach": "Topological sort using Kahn's algorithm. Track in-degrees and process nodes with BFS.",
      "related_concepts": [
        "topological_sort",
        "cycle_detection"
      ],
      "cpp_solution": "\n#include <vector>\n#include <queue>\nusing namespace std;\n\nbool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n    vector<vector<int>> adj(numCourses);\n    vector<int> indegree(numCourses);\n    for(auto& p : prerequisites) {\n        adj[p[1]].push_back(p[0]);\n        indegree[p[0]]++;\n    }\n    \n    queue<int> q;\n    for(int i=0; i<numCourses; i++)\n        if(indegree[i] == 0) q.push(i);\n    \n    int count = 0;\n    while(!q.empty()) {\n        int u = q.front(); q.pop();\n        count++;\n        for(int v : adj[u]) {\n            if(--indegree[v] == 0)\n                q.push(v);\n        }\n    }\n    return count == numCourses;\n}\n"
    },
    "network_delay_time": {
      "id": "network_delay_time",
      "title": "Network Delay Time",
      "difficulty": "medium",
      "description": "Find the minimum time for all nodes to receive a signal from node k using Dijkstra's algorithm.",
      "input_format": "List of travel times [u,v,w], integer n (nodes), integer k (source)",
      "output_format": "Integer representing minimum time or -1",
      "constraints": [
        "1 ≤ k ≤ n ≤ 100",
        "0 ≤ w ≤ 100"
      ],
      "example": {
        "input": "times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2",
        "output": "2",
        "explanation": "Maximum delay from node 2 is 2 units"
      },
      "solution_approach": "Dijkstra's algorithm with priority queue to track shortest paths.",
      "related_concepts": [
        "dijkstra",
        "shortest_path"
      ],
      "cpp_solution": "\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nint networkDelayTime(vector<vector<int>>& times, int n, int k) {\n    vector<vector<pair<int,int>>> adj(n+1);\n    for(auto& t : times)\n        adj[t[0]].emplace_back(t[1], t[2]);\n    \n    vector<int> dist(n+1, INT_MAX);\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;\n    pq.emplace(0, k);\n    dist[k] = 0;\n    \n    while(!pq.empty()) {\n        auto [d, u] = pq.top(); pq.pop();\n        if(d > dist[u]) continue;\n        for(auto [v, w] : adj[u]) {\n            if(dist[v] > d + w) {\n                dist[v] = d + w;\n                pq.emplace(dist[v], v);\n            }\n        }\n    }\n    \n    int max_dist = *max_element(dist.begin()+1, dist.end());\n    return max_dist == INT_MAX ? -1 : max_dist;\n}\n"
    },
    "cheapest_flights_within_k_stops": {
      "id": "cheapest_flights_within_k_stops",
      "title": "Cheapest Flights Within K Stops",
      "difficulty": "hard",
      "description": "Find the cheapest price from src to dst with at most k stops using BFS with pruning.",
      "input_format": "Integer n, list of flights [from,to,price], integer src, integer dst, integer k",
      "output_format": "Integer price or -1",
      "constraints": [
        "1 ≤ n ≤ 100",
        "0 ≤ flights.length ≤ (n*(n-1))/2"
      ],
      "example": {
        "input": "n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1",
        "output": "200",
        "explanation": "0->1->2 with 1 stop"
      },
      "solution_approach": "Bellman-Ford with BFS-like level processing. Track minimum costs for each stop level.",
      "related_concepts": [
        "bfs",
        "dynamic_programming"
      ],
      "cpp_solution": "\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n    vector<int> dist(n, INT_MAX);\n    dist[src] = 0;\n    \n    for(int i=0; i<=k; i++) {\n        vector<int> temp(dist);\n        for(auto& f : flights) {\n            int u = f[0], v = f[1], w = f[2];\n            if(dist[u] != INT_MAX && temp[v] > dist[u] + w)\n                temp[v] = dist[u] + w;\n        }\n        dist = temp;\n    }\n    return dist[dst] == INT_MAX ? -1 : dist[dst];\n}\n"
    },
    "minimum_height_trees": {
      "id": "minimum_height_trees",
      "title": "Minimum Height Trees",
      "difficulty": "medium",
      "description": "Find all possible MHT roots by peeling leaf nodes layer by layer using BFS.",
      "input_format": "Integer n and list of edges",
      "output_format": "List of root indices",
      "constraints": [
        "1 ≤ n ≤ 2*10^4"
      ],
      "example": {
        "input": "n = 4, edges = [[1,0],[1,2],[1,3]]",
        "output": "[1]",
        "explanation": "Root 1 gives minimum height 1"
      },
      "solution_approach": "BFS from leaf nodes. Remove leaves until 1-2 nodes remain.",
      "related_concepts": [
        "topological_sort",
        "graph_peeling"
      ],
      "cpp_solution": "\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n    if(n == 1) return {0};\n    vector<unordered_set<int>> adj(n);\n    for(auto& e : edges) {\n        adj[e[0]].insert(e[1]);\n        adj[e[1]].insert(e[0]);\n    }\n    \n    queue<int> q;\n    for(int i=0; i<n; i++)\n        if(adj[i].size() == 1) q.push(i);\n    \n    while(n > 2) {\n        int sz = q.size();\n        n -= sz;\n        for(int i=0; i<sz; i++) {\n            int u = q.front(); q.pop();\n            for(int v : adj[u]) {\n                adj[v].erase(u);\n                if(adj[v].size() == 1) q.push(v);\n            }\n        }\n    }\n    \n    vector<int> res;\n    while(!q.empty()) {\n        res.push_back(q.front());\n        q.pop();\n    }\n    return res;\n}\n"
    },
    "redundant_connection": {
      "id": "redundant_connection",
      "title": "Redundant Connection",
      "difficulty": "medium",
      "description": "Find the edge that can be removed to make the graph a tree using Union-Find.",
      "input_format": "List of edges in a graph",
      "output_format": "Redundant edge",
      "constraints": [
        "3 ≤ n ≤ 1000"
      ],
      "example": {
        "input": "[[1,2],[1,3],[2,3]]",
        "output": "[2,3]",
        "explanation": "Cycle formed by 1-2-3"
      },
      "solution_approach": "Union-Find to detect first edge creating a cycle.",
      "related_concepts": [
        "union_find",
        "cycle_detection"
      ],
      "cpp_solution": "\n#include <vector>\nusing namespace std;\n\nclass UnionFind {\n    vector<int> parent;\npublic:\n    UnionFind(int n) : parent(n) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n    int find(int u) {\n        if(parent[u] != u) parent[u] = find(parent[u]);\n        return parent[u];\n    }\n    bool unite(int u, int v) {\n        int pu = find(u), pv = find(v);\n        if(pu == pv) return false;\n        parent[pu] = pv;\n        return true;\n    }\n};\n\nvector<int> findRedundantConnection(vector<vector<int>>& edges) {\n    UnionFind uf(edges.size()+1);\n    for(auto& e : edges)\n        if(!uf.unite(e[0], e[1])) return e;\n    return {};\n}\n"
    },
    "word_ladder": {
      "id": "word_ladder",
      "title": "Word Ladder",
      "difficulty": "hard",
      "description": "Find the shortest transformation sequence from beginWord to endWord using BFS.",
      "input_format": "String beginWord, endWord, and list of words",
      "output_format": "Integer length of transformation sequence",
      "constraints": [
        "1 ≤ beginWord.length ≤ 10",
        "endWord.length == beginWord.length"
      ],
      "example": {
        "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
        "output": "5",
        "explanation": "hit -> hot -> dot -> dog -> cog"
      },
      "solution_approach": "BFS with wildcard pattern generation. Track visited words.",
      "related_concepts": [
        "bfs",
        "string_manipulation"
      ],
      "cpp_solution": "\n#include <vector>\n#include <queue>\n#include <unordered_set>\nusing namespace std;\n\nint ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n    unordered_set<string> dict(wordList.begin(), wordList.end());\n    if(!dict.count(endWord)) return 0;\n    \n    queue<string> q;\n    q.push(beginWord);\n    int steps = 1;\n    \n    while(!q.empty()) {\n        int sz = q.size();\n        while(sz--) {\n            string word = q.front(); q.pop();\n            if(word == endWord) return steps;\n            \n            for(int i=0; i<word.size(); i++) {\n                char orig = word[i];\n                for(char c='a'; c<='z'; c++) {\n                    word[i] = c;\n                    if(dict.count(word)) {\n                        q.push(word);\n                        dict.erase(word);\n                    }\n                }\n                word[i] = orig;\n            }\n        }\n        steps++;\n    }\n    return 0;\n}\n"
    },
    "alien_dictionary": {
      "id": "alien_dictionary",
      "title": "Alien Dictionary",
      "difficulty": "hard",
      "description": "Determine the order of characters in an alien language using topological sort.",
      "input_format": "List of words in alien dictionary order",
      "output_format": "String representing character order",
      "constraints": [
        "1 ≤ words.length ≤ 100"
      ],
      "example": {
        "input": "[\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]",
        "output": "\"wertf\"",
        "explanation": "Valid character order derived from word comparisons"
      },
      "solution_approach": "Build graph from consecutive word comparisons. Perform topological sort.",
      "related_concepts": [
        "topological_sort",
        "graph_construction"
      ],
      "cpp_solution": "\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstring alienOrder(vector<string>& words) {\n    unordered_map<char, vector<char>> adj;\n    unordered_map<char, int> indegree;\n    \n    for(auto& w : words)\n        for(char c : w)\n            indegree[c] = 0;\n    \n    for(int i=0; i<words.size()-1; i++) {\n        string w1 = words[i], w2 = words[i+1];\n        int len = min(w1.size(), w2.size());\n        bool found = false;\n        for(int j=0; j<len; j++) {\n            if(w1[j] != w2[j]) {\n                adj[w1[j]].push_back(w2[j]);\n                indegree[w2[j]]++;\n                found = true;\n                break;\n            }\n        }\n        if(!found && w1.size() > w2.size()) return \"\";\n    }\n    \n    queue<char> q;\n    for(auto& [c, cnt] : indegree)\n        if(cnt == 0) q.push(c);\n    \n    string res;\n    while(!q.empty()) {\n        char c = q.front(); q.pop();\n        res += c;\n        for(char nei : adj[c]) {\n            if(--indegree[nei] == 0)\n                q.push(nei);\n        }\n    }\n    return res.size() == indegree.size() ? res : \"\";\n}\n"
    },
    "swim_in_rising_water": {
      "id": "swim_in_rising_water",
      "title": "Swim in Rising Water",
      "difficulty": "hard",
      "description": "Find the least time to reach the bottom-right cell using Dijkstra's with priority queue.",
      "input_format": "2D grid of elevations",
      "output_format": "Integer minimum time",
      "constraints": [
        "n == grid.length",
        "2 ≤ n ≤ 50"
      ],
      "example": {
        "input": "[[0,2],[1,3]]",
        "output": "3",
        "explanation": "Path 0->1->3 with max elevation 3"
      },
      "solution_approach": "Dijkstra's algorithm prioritizing minimal max elevation in path.",
      "related_concepts": [
        "dijkstra",
        "priority_queue"
      ],
      "cpp_solution": "\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint swimInWater(vector<vector<int>>& grid) {\n    int n = grid.size();\n    priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;\n    pq.push({grid[0][0], 0, 0});\n    vector<vector<bool>> visited(n, vector<bool>(n));\n    visited[0][0] = true;\n    \n    vector<pair<int,int>> dirs = {{-1,0},{1,0},{0,-1},{0,1}};\n    \n    while(!pq.empty()) {\n        auto v = pq.top(); pq.pop();\n        int t = v[0], i = v[1], j = v[2];\n        if(i == n-1 && j == n-1) return t;\n        \n        for(auto [di, dj] : dirs) {\n            int ni = i+di, nj = j+dj;\n            if(ni>=0 && ni<n && nj>=0 && nj<n && !visited[ni][nj]) {\n                visited[ni][nj] = true;\n                pq.push({max(t, grid[ni][nj]), ni, nj});\n            }\n        }\n    }\n    return -1;\n}\n"
    },
    "critical_connections": {
      "id": "critical_connections",
      "title": "Critical Connections in a Network",
      "difficulty": "hard",
      "description": "Find all bridges in a graph using Tarjan's algorithm.",
      "input_format": "Integer n and list of connections",
      "output_format": "List of critical edges",
      "constraints": [
        "2 ≤ n ≤ 10^5"
      ],
      "example": {
        "input": "n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]",
        "output": "[[1,3]]",
        "explanation": "Edge 1-3 is the only bridge"
      },
      "solution_approach": "Tarjan's algorithm tracking discovery and low times during DFS.",
      "related_concepts": [
        "tarjan",
        "bridge_detection"
      ],
      "cpp_solution": "\n#include <vector>\nusing namespace std;\n\nclass Solution {\n    vector<vector<int>> ans;\n    vector<int> disc, low;\n    int time = 1;\n    \n    void dfs(vector<vector<int>>& adj, int u, int parent) {\n        disc[u] = low[u] = time++;\n        for(int v : adj[u]) {\n            if(v == parent) continue;\n            if(!disc[v]) {\n                dfs(adj, v, u);\n                low[u] = min(low[u], low[v]);\n                if(low[v] > disc[u])\n                    ans.push_back({u, v});\n            } else {\n                low[u] = min(low[u], disc[v]);\n            }\n        }\n    }\npublic:\n    vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {\n        vector<vector<int>> adj(n);\n        for(auto& c : connections) {\n            adj[c[0]].push_back(c[1]);\n            adj[c[1]].push_back(c[0]);\n        }\n        disc.resize(n);\n        low.resize(n);\n        dfs(adj, 0, -1);\n        return ans;\n    }\n};\n"
    },
  "prims_vs_kruskal": {
        "id": "prims_vs_kruskal",
        "title": "Prim's vs Kruskal's Algorithm",
        "difficulty": "medium",
        "description": "Compare Prim's and Kruskal's algorithms for finding Minimum Spanning Trees (MST) in terms of time complexity, implementation, and suitable use cases.",
        "input_format": "A connected undirected graph with weighted edges",
        "output_format": "MST using both algorithms",
        "constraints": [
          "1 ≤ vertices ≤ 10^5",
          "0 ≤ edges ≤ 10^6"
        ],
        "example": {
          "input": "Graph with 4 vertices and edges: (0-1, 1), (1-2, 2), (2-3, 3), (3-0, 4)",
          "output": "MST edges: [(0,1), (1,2), (2,3)] for both algorithms"
        },
        "solution_approach": "Prim's uses priority queue for dense graphs (O(V²)), Kruskal's uses union-find for sparse graphs (O(E log E)). Kruskal's selects edges greedily, Prim's grows tree from a node.",
        "related_concepts": [
          "greedy_algorithm",
          "union_find",
          "priority_queue"
        ],
        "cpp_solution": "// Prim's snippet\npriority_queue<pair<int, int>> pq;\n// Kruskal's snippet\nsort(edges.begin(), edges.end());"
      },
      "clone_graph": {
        "id": "clone_graph",
        "title": "Clone Graph",
        "difficulty": "medium",
        "description": "Create a deep copy of a connected undirected graph using DFS/BFS with a hash map to track original-clone relationships.",
        "input_format": "Adjacency list representation of a graph",
        "output_format": "Cloned adjacency list",
        "constraints": [
          "0 ≤ nodes ≤ 1000"
        ],
        "example": {
          "input": "[[2,4],[1,3],[2,4],[1,3]]",
          "output": "Same structure with new nodes"
        },
        "solution_approach": "DFS/BFS traversal with hash map. For each node, create clone and recursively copy neighbors.",
        "related_concepts": [
          "hash_map",
          "graph_traversal"
        ],
        "cpp_solution": "unordered_map<Node*, Node*> copies;\nNode* clone(Node* node) {\n  if (!node) return nullptr;\n  if (!copies.count(node)) {\n    copies[node] = new Node(node->val);\n    for (Node* neighbor : node->neighbors)\n      copies[node]->neighbors.push_back(clone(neighbor));\n  }\n  return copies[node];\n}"
      },
      "graph_valid_tree": {
        "id": "graph_valid_tree",
        "title": "Graph Valid Tree",
        "difficulty": "medium",
        "description": "Determine if a graph with n nodes is a valid tree (connected, no cycles) using Union-Find or DFS cycle detection.",
        "input_format": "Integer n and list of edges",
        "output_format": "Boolean indicating tree validity",
        "constraints": [
          "1 ≤ n ≤ 2000",
          "0 ≤ edges.length ≤ 5000"
        ],
        "example": {
          "input": "n=5, edges=[[0,1],[0,2],[0,3],[1,4]]",
          "output": "true"
        },
        "solution_approach": "Union-Find: Check for cycles during edge processing. Valid if edges = n-1 and one component.",
        "related_concepts": [
          "cycle_detection",
          "connectivity"
        ],
        "cpp_solution": "vector<int> parent;\nint find(int x) {\n  return parent[x] == x ? x : parent[x] = find(parent[x]);\n}\nbool validTree(int n, vector<vector<int>>& edges) {\n  if (edges.size() != n-1) return false;\n  parent.resize(n);\n  iota(parent.begin(), parent.end(), 0);\n  for (auto& e : edges) {\n    int fx = find(e[0]), fy = find(e[1]);\n    if (fx == fy) return false;\n    parent[fx] = fy;\n  }\n  return true;\n}"
      },
      "reconstruct_itinerary": {
        "id": "reconstruct_itinerary",
        "title": "Reconstruct Itinerary",
        "difficulty": "hard",
        "description": "Find the lexicographically smallest itinerary using all tickets exactly once (Eulerian path).",
        "input_format": "List of airline tickets [from, to]",
        "output_format": "Lexicographically smallest itinerary",
        "constraints": [
          "1 ≤ tickets.length ≤ 300"
        ],
        "example": {
          "input": "[[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]",
          "output": "[\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]"
        },
        "solution_approach": "Hierholzer's algorithm: DFS with lexical ordering and post-order collection. Use multiset for destinations.",
        "related_concepts": [
          "eulerian_path",
          "lexicographical_order"
        ],
        "cpp_solution": "unordered_map<string, multiset<string>> graph;\nvector<string> route;\nvoid visit(string airport) {\n  while (!graph[airport].empty()) {\n    string next = *graph[airport].begin();\n    graph[airport].erase(graph[airport].begin());\n    visit(next);\n  }\n  route.push_back(airport);\n}\n// Sort tickets, build graph, reverse route"
      },
      "walls_and_gates": {
        "id": "walls_and_gates",
        "title": "Walls and Gates",
        "difficulty": "medium",
        "description": "Fill each room with distance to nearest gate using multi-source BFS.",
        "input_format": "2D grid with -1 (wall), 0 (gate), INF (empty room)",
        "output_format": "Updated grid with shortest distances",
        "constraints": [
          "m == grid.length",
          "n == grid[i].length"
        ],
        "example": {
          "input": "[[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1]]",
          "output": "[[3,-1,0,1],[2,2,1,-1]]"
        },
        "solution_approach": "Initialize queue with all gates. BFS propagate distance level by level.",
        "related_concepts": [
          "multi_source_bfs",
          "shortest_path"
        ],
        "cpp_solution": "queue<pair<int, int>> q;\nfor (int i=0; i<m; i++)\n  for (int j=0; j<n; j++)\n    if (grid[i][j] == 0) q.push({i,j});\nwhile (!q.empty()) {\n  auto [x,y] = q.front(); q.pop();\n  for (auto [dx,dy] : dirs) {\n    int nx=x+dx, ny=y+dy;\n    if (nx>=0 && ny>=0 && nx<m && ny<n && grid[nx][ny]==INT_MAX) {\n      grid[nx][ny] = grid[x][y]+1;\n      q.push({nx,ny});\n    }\n  }\n}"
      },
      "strongly_connected_components": {
        "id": "strongly_connected_components",
        "title": "Strongly Connected Components",
        "difficulty": "hard",
        "description": "Find all SCCs in directed graph using Kosaraju's algorithm.",
        "input_format": "Directed graph adjacency list",
        "output_format": "List of SCCs",
        "constraints": [
          "1 ≤ vertices ≤ 10^5"
        ],
        "example": {
          "input": "[[1],[2],[0],[4],[5],[3]]",
          "output": "[[0,1,2],[3,4,5]]"
        },
        "solution_approach": "1. DFS for finish times 2. Transpose graph 3. DFS in reverse finish order.",
        "related_concepts": [
          "scc",
          "transpose_graph"
        ],
        "cpp_solution": "vector<int> order;\nvector<bool> vis;\nvoid dfs1(int u) {\n  vis[u] = true;\n  for (int v : adj[u])\n    if (!vis[v]) dfs1(v);\n  order.push_back(u);\n}\n// Transpose graph and DFS again"
      },
      "path_max_probability": {
        "id": "path_max_probability",
        "title": "Path with Maximum Probability",
        "difficulty": "medium",
        "description": "Find path between start and end with max success probability using modified Dijkstra's.",
        "input_format": "Edges with probabilities, start, end",
        "output_format": "Maximum probability",
        "constraints": [
          "1 ≤ n ≤ 10^4"
        ],
        "example": {
          "input": "n=3, edges=[[0,1],[1,2],[0,2]], succProb=[0.5,0.5,0.3], start=0, end=2",
          "output": "0.5"
        },
        "solution_approach": "Max-heap Dijkstra's with probability multiplication. Use -log(p) for standard SP.",
        "related_concepts": [
          "modified_dijkstra",
          "probability"
        ],
        "cpp_solution": "priority_queue<pair<double, int>> pq;\npq.push({1.0, start});\nwhile (!pq.empty()) {\n  auto [prob, u] = pq.top(); pq.pop();\n  if (u == end) return prob;\n  for (auto [v, p] : graph[u])\n    if (dist[v] < prob*p) {\n      dist[v] = prob*p;\n      pq.push({dist[v], v});\n    }\n}"
      },
      "jump_game_iv": {
        "id": "jump_game_iv",
        "title": "Jump Game IV",
        "difficulty": "hard",
        "description": "Find minimum jumps to reach last index with adjacency list optimization.",
        "input_format": "Array of integers",
        "output_format": "Minimum jumps",
        "constraints": [
          "1 ≤ arr.length ≤ 5*10^4"
        ],
        "example": {
          "input": "[100,-23,-23,404,100,23,23,23,3,404]",
          "output": "3"
        },
        "solution_approach": "BFS with hash map grouping same values. Prune visited groups.",
        "related_concepts": [
          "bfs",
          "pruning"
        ],
        "cpp_solution": "unordered_map<int, vector<int>> valIndices;\nqueue<int> q;\nq.push(0);\nwhile (!q.empty()) {\n  for (int i=q.size(); i>0; i--) {\n    int u = q.front(); q.pop();\n    if (u == n-1) return steps;\n    for (int v : valIndices[arr[u]]) {\n      if (!vis[v]) q.push(v), vis[v]=true;\n    }\n    valIndices.erase(arr[u]);\n  }\n}"
      },
      "min_knight_moves": {
        "id": "min_knight_moves",
        "title": "Minimum Knight Moves",
        "difficulty": "medium",
        "description": "Find minimum moves for knight to reach target on infinite chessboard using BFS.",
        "input_format": "Target coordinates x, y",
        "output_format": "Integer moves",
        "constraints": [
          "-300 ≤ x, y ≤ 300"
        ],
        "example": {
          "input": "x=2, y=1",
          "output": "1"
        },
        "solution_approach": "BFS with visited matrix offset to handle negatives. 8-direction moves.",
        "related_concepts": [
          "bfs",
          "coordinate_offset"
        ],
        "cpp_solution": "queue<pair<int, int>> q;\nq.push({0,0});\nvis[310][310] = true;\nwhile (!q.empty()) {\n  auto [x,y] = q.front(); q.pop();\n  if (x==tx && y==ty) return steps;\n  for (auto [dx,dy] : dirs)\n    if (!vis[x+dx+310][y+dy+310]) {\n      vis[x+dx+310][y+dy+310] = true;\n      q.push({x+dx, y+dy});\n    }\n}"
      },
      "evaluate_division": {
        "id": "evaluate_division",
        "title": "Evaluate Division",
        "difficulty": "medium",
        "description": "Compute division results from equations using graph DFS/BFS.",
        "input_format": "List of equations and queries",
        "output_format": "List of results",
        "constraints": [
          "1 ≤ equations.length ≤ 20"
        ],
        "example": {
          "input": "equations=[[\"a\",\"b\"],[\"b\",\"c\"]], values=[2.0,3.0], queries=[[\"a\",\"c\"]]",
          "output": "[6.0]"
        },
        "solution_approach": "Build graph with reciprocal edges. DFS/BFS to find path and multiply weights.",
        "related_concepts": [
          "weighted_graph",
          "path_product"
        ],
        "cpp_solution": "unordered_map<string, vector<pair<string, double>>> graph;\ndouble dfs(string u, string target, unordered_set<string>& vis) {\n  if (u == target) return 1.0;\n  vis.insert(u);\n  for (auto [v, w] : graph[u])\n    if (!vis.count(v))\n      if (double res = dfs(v, target, vis); res != -1) return w*res;\n  return -1;\n}"
  },
"path_min_effort": {
      "id": "path_min_effort",
      "title": "Path with Minimum Effort",
      "difficulty": "medium",
      "description": "Find the route from top-left to bottom-right of a grid where the maximum absolute difference between consecutive cells is minimized. Use binary search + BFS.",
      "input_format": "2D grid of heights",
      "output_format": "Integer minimum effort",
      "constraints": [
        "rows == grid.length",
        "1 ≤ rows, columns ≤ 100"
      ],
      "example": {
        "input": "[[1,2,2],[3,8,2],[5,3,5]]",
        "output": "2",
        "explanation": "Path 1→3→5→3→5 has max diff |3-5|=2"
      },
      "solution_approach": "Binary search possible effort values. For each mid, check path existence using BFS with effort ≤ mid.",
      "related_concepts": [
        "binary_search",
        "bfs"
      ],
      "cpp_solution": "\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint minimumEffortPath(vector<vector<int>>& heights) {\n    int left=0, right=1e6;\n    vector<pair<int,int>> dirs = {{-1,0},{1,0},{0,-1},{0,1}};\n    \n    while(left < right) {\n        int mid = (left + right)/2;\n        queue<pair<int,int>> q;\n        vector<vector<bool>> vis(heights.size(), vector<bool>(heights[0].size()));\n        q.push({0,0});\n        vis[0][0] = true;\n        \n        while(!q.empty()) {\n            auto [x,y] = q.front(); q.pop();\n            for(auto [dx,dy] : dirs) {\n                int nx=x+dx, ny=y+dy;\n                if(nx>=0 && ny>=0 && nx<heights.size() && ny<heights[0].size() && !vis[nx][ny] && abs(heights[nx][ny]-heights[x][y])<=mid) {\n                    vis[nx][ny] = true;\n                    q.push({nx,ny});\n                }\n            }\n        }\n        \n        if(vis.back().back()) right = mid;\n        else left = mid+1;\n    }\n    return left;\n}\n"
    },
    "nearest_exit": {
      "id": "nearest_exit",
      "title": "Nearest Exit from Entrance",
      "difficulty": "medium",
      "description": "Find the shortest path from entrance to any exit (edge cell) in a maze using optimized BFS.",
      "input_format": "2D grid with '.' (empty) and '+' (wall), entrance coordinates",
      "output_format": "Integer steps or -1",
      "constraints": [
        "m == maze.length",
        "1 ≤ m, n ≤ 100"
      ],
      "example": {
        "input": "maze = [[\"+\",\"+\",\".\",\"+\"],[\".\",\".\",\".\",\"+\"],[\"+\",\"+\",\"+\",\".\"]], entrance = [1,2]",
        "output": "1",
        "explanation": "Move left to [1,1] which is an exit"
      },
      "solution_approach": "BFS level-order traversal. Check edge cells (excluding entrance) for exits.",
      "related_concepts": [
        "bfs",
        "grid_traversal"
      ],
      "cpp_solution": "\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {\n    int m=maze.size(), n=maze[0].size();\n    queue<pair<int,int>> q;\n    q.push({entrance[0], entrance[1]});\n    maze[entrance[0]][entrance[1]] = '+';\n    vector<pair<int,int>> dirs = {{-1,0},{1,0},{0,-1},{0,1}};\n    \n    for(int steps=0; !q.empty(); steps++) {\n        for(int sz=q.size(); sz>0; sz--) {\n            auto [x,y] = q.front(); q.pop();\n            if((x==0 || y==0 || x==m-1 || y==n-1) && !(x==entrance[0] && y==entrance[1])) \n                return steps;\n            for(auto [dx,dy] : dirs) {\n                int nx=x+dx, ny=y+dy;\n                if(nx>=0 && ny>=0 && nx<m && ny<n && maze[nx][ny]=='.') {\n                    maze[nx][ny] = '+';\n                    q.push({nx,ny});\n                }\n            }\n        }\n    }\n    return -1;\n}\n"
    },
    "shortest_path_all_nodes": {
      "id": "shortest_path_all_nodes",
      "title": "Shortest Path Visiting All Nodes",
      "difficulty": "hard",
      "description": "Find the shortest path that visits every node in a graph using BFS with bitmask state tracking.",
      "input_format": "Adjacency list of undirected graph",
      "output_format": "Integer shortest path length",
      "constraints": [
        "1 ≤ n ≤ 12"
      ],
      "example": {
        "input": "[[1,2,3],[0],[0],[0]]",
        "output": "4",
        "explanation": "Path 1→0→2→0→3 (length 4 edges)"
      },
      "solution_approach": "BFS with state (current node, visited mask). Track visited states to avoid cycles.",
      "related_concepts": [
        "bitmasking",
        "state_bfs"
      ],
      "cpp_solution": "\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint shortestPathLength(vector<vector<int>>& graph) {\n    int n = graph.size(), full_mask = (1<<n)-1;\n    queue<tuple<int,int,int>> q;\n    vector<vector<bool>> vis(n, vector<bool>(1<<n));\n    \n    for(int i=0; i<n; i++) {\n        q.push({i, 1<<i, 0});\n        vis[i][1<<i] = true;\n    }\n    \n    while(!q.empty()) {\n        auto [u, mask, dist] = q.front(); q.pop();\n        if(mask == full_mask) return dist;\n        for(int v : graph[u]) {\n            int new_mask = mask | (1<<v);\n            if(!vis[v][new_mask]) {\n                vis[v][new_mask] = true;\n                q.push({v, new_mask, dist+1});\n            }\n        }\n    }\n    return -1;\n}\n"
    },
    "largest_color_dag": {
      "id": "largest_color_dag",
      "title": "Largest Color Value in DAG",
      "difficulty": "hard",
      "description": "Find the maximum frequency of any color in all possible paths of a DAG using topological sort + DP.",
      "input_format": "String colors and list of directed edges",
      "output_format": "Integer maximum color count",
      "constraints": [
        "n == colors.length",
        "1 ≤ n ≤ 10^5"
      ],
      "example": {
        "input": "colors = \"abaca\", edges = [[0,1],[0,2],[2,3],[3,4]]",
        "output": "3",
        "explanation": "Path 0→2→3→4 has 3 'a's"
      },
      "solution_approach": "Topological order processing. Maintain DP array tracking max counts for each color per node.",
      "related_concepts": [
        "topological_sort",
        "dynamic_programming"
      ],
      "cpp_solution": "\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint largestPathValue(string colors, vector<vector<int>>& edges) {\n    int n = colors.size();\n    vector<vector<int>> adj(n);\n    vector<int> indeg(n);\n    vector<vector<int>> dp(n, vector<int>(26));\n    \n    for(auto& e : edges) {\n        adj[e[0]].push_back(e[1]);\n        indeg[e[1]]++;\n    }\n    \n    queue<int> q;\n    for(int i=0; i<n; i++)\n        if(indeg[i]==0) q.push(i);\n    \n    int visited = 0, ans = 0;\n    while(!q.empty()) {\n        int u = q.front(); q.pop();\n        visited++;\n        dp[u][colors[u]-'a']++;\n        ans = max(ans, dp[u][colors[u]-'a']);\n        \n        for(int v : adj[u]) {\n            for(int c=0; c<26; c++)\n                dp[v][c] = max(dp[v][c], dp[u][c]);\n            if(--indeg[v]==0) q.push(v);\n        }\n    }\n    return visited==n ? ans : -1;\n}\n"
    },
    "min_time_collect_apples": {
      "id": "min_time_collect_apples",
      "title": "Minimum Time to Collect Apples",
      "difficulty": "medium",
      "description": "Calculate total time to collect all apples in a tree using DFS post-order traversal.",
      "input_format": "List of edges, hasApple list",
      "output_format": "Integer total time",
      "constraints": [
        "1 ≤ n ≤ 10^5"
      ],
      "example": {
        "input": "edges = [[0,1],[0,2],[1,4],[1,5],[2,3]], hasApple = [false,false,true,false,true,true]",
        "output": "8",
        "explanation": "Paths: 0→2 (2) + 0→1→4 (4) + 0→1→5 (2) = 8"
      },
      "solution_approach": "DFS post-order traversal. Add 2*edge time if subtree has apples.",
      "related_concepts": [
        "dfs",
        "tree_traversal"
      ],
      "cpp_solution": "\n#include <vector>\nusing namespace std;\n\nint dfs(int u, int parent, vector<vector<int>>& adj, vector<bool>& hasApple) {\n    int total = 0;\n    for(int v : adj[u]) {\n        if(v == parent) continue;\n        int childTime = dfs(v, u, adj, hasApple);\n        if(childTime > 0 || hasApple[v])\n            total += childTime + 2;\n    }\n    return total;\n}\n\nint minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\n    vector<vector<int>> adj(n);\n    for(auto& e : edges) {\n        adj[e[0]].push_back(e[1]);\n        adj[e[1]].push_back(e[0]);\n    }\n    return dfs(0, -1, adj, hasApple);\n}\n"
    },
  "maximum_subarray": {
        "id": "maximum_subarray",
        "title": "Maximum Subarray",
        "difficulty": "easy",
        "description": "Find the contiguous subarray with the largest sum using Kadane's algorithm.",
        "input_format": "An array of integers nums",
        "output_format": "Integer maximum sum",
        "constraints": [
          "1 ≤ nums.length ≤ 10^5",
          "-10^4 ≤ nums[i] ≤ 10^4"
        ],
        "example": {
          "input": "[-2,1,-3,4,-1,2,1,-5,4]",
          "output": "6",
          "explanation": "Subarray [4,-1,2,1] has the largest sum 6"
        },
        "solution_approach": "Track current and maximum sums. Update current as max(nums[i], current + nums[i]).",
        "related_concepts": [
          "dynamic_programming",
          "greedy_algorithm"
        ],
        "cpp_solution": "\n#include <vector>\n#include <climits>\nusing namespace std;\n\nint maxSubArray(vector<int>& nums) {\n    int current = nums[0], max_sum = nums[0];\n    for(int i=1; i<nums.size(); i++) {\n        current = max(nums[i], current + nums[i]);\n        max_sum = max(max_sum, current);\n    }\n    return max_sum;\n}\n"
      },
      "longest_palindromic_substring": {
        "id": "longest_palindromic_substring",
        "title": "Longest Palindromic Substring",
        "difficulty": "medium",
        "description": "Find the longest palindromic substring in a string using expand-around-center approach.",
        "input_format": "String s",
        "output_format": "Longest palindromic substring",
        "constraints": [
          "1 ≤ s.length ≤ 1000"
        ],
        "example": {
          "input": "\"babad\"",
          "output": "\"bab\"",
          "explanation": "\"aba\" is also a valid answer"
        },
        "solution_approach": "Expand around each character and between characters. Track maximum length and start index.",
        "related_concepts": [
          "two_pointers",
          "string_manipulation"
        ],
        "cpp_solution": "\nclass Solution {\n    int expand(string &s, int l, int r) {\n        while(l >=0 && r <s.size() && s[l]==s[r]) l--,r++;\n        return r-l-1;\n    }\npublic:\n    string longestPalindrome(string s) {\n        int start=0, max_len=0;\n        for(int i=0; i<s.size(); i++) {\n            int len1 = expand(s,i,i);\n            int len2 = expand(s,i,i+1);\n            int len = max(len1,len2);\n            if(len > max_len) {\n                max_len = len;\n                start = i - (len-1)/2;\n            }\n        }\n        return s.substr(start,max_len);\n    }\n};\n"
      },
      "coin_change_ii": {
        "id": "coin_change_ii",
        "title": "Coin Change II",
        "difficulty": "medium",
        "description": "Compute the number of combinations to make amount using given coins (unbounded knapsack).",
        "input_format": "Array of coins and integer amount",
        "output_format": "Integer number of combinations",
        "constraints": [
          "1 ≤ coins.length ≤ 300",
          "0 ≤ amount ≤ 5000"
        ],
        "example": {
          "input": "coins = [1,2,5], amount = 5",
          "output": "4",
          "explanation": "5=5, 2+2+1, 2+1+1+1, 1+1+1+1+1"
        },
        "solution_approach": "Dynamic programming where dp[i] += dp[i - coin] for each coin.",
        "related_concepts": [
          "unbounded_knapsack",
          "dynamic_programming"
        ],
        "cpp_solution": "\nint change(int amount, vector<int>& coins) {\n    vector<int> dp(amount+1);\n    dp[0] = 1;\n    for(int coin : coins)\n        for(int i=coin; i<=amount; i++)\n            dp[i] += dp[i - coin];\n    return dp[amount];\n}\n"
      },
      "edit_distance": {
        "id": "edit_distance",
        "title": "Edit Distance",
        "difficulty": "hard",
        "description": "Find the minimum operations (insert/delete/replace) to convert word1 to word2.",
        "input_format": "Two strings word1 and word2",
        "output_format": "Integer minimum operations",
        "constraints": [
          "0 ≤ word1.length, word2.length ≤ 500"
        ],
        "example": {
          "input": "\"horse\", \"ros\"",
          "output": "3",
          "explanation": "horse → rorse (replace 'h'), rorse → rose (remove 'r'), rose → ros (remove 'e')"
        },
        "solution_approach": "2D DP where dp[i][j] = min of insert, delete, replace operations.",
        "related_concepts": [
          "dynamic_programming",
          "string_manipulation"
        ],
        "cpp_solution": "\nint minDistance(string word1, string word2) {\n    int m=word1.size(), n=word2.size();\n    vector<vector<int>> dp(m+1, vector<int>(n+1));\n    for(int i=0; i<=m; i++) dp[i][0] = i;\n    for(int j=0; j<=n; j++) dp[0][j] = j;\n    \n    for(int i=1; i<=m; i++)\n        for(int j=1; j<=n; j++)\n            if(word1[i-1] == word2[j-1])\n                dp[i][j] = dp[i-1][j-1];\n            else\n                dp[i][j] = 1 + min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]});\n    return dp[m][n];\n}\n"
      },
      "maximum_product_subarray": {
        "id": "maximum_product_subarray",
        "title": "Maximum Product Subarray",
        "difficulty": "medium",
        "description": "Find the contiguous subarray with maximum product (handling negative numbers).",
        "input_format": "Array of integers nums",
        "output_format": "Integer maximum product",
        "constraints": [
          "1 ≤ nums.length ≤ 2*10^4",
          "-10 ≤ nums[i] ≤ 10"
        ],
        "example": {
          "input": "[2,3,-2,4]",
          "output": "6",
          "explanation": "Subarray [2,3] has maximum product 6"
        },
        "solution_approach": "Track current max and min products (handling negatives). Update global max.",
        "related_concepts": [
          "dynamic_programming",
          "array_manipulation"
        ],
        "cpp_solution": "\nint maxProduct(vector<int>& nums) {\n    int current_max = nums[0], current_min = nums[0], global_max = nums[0];\n    for(int i=1; i<nums.size(); i++) {\n        int temp = current_max;\n        current_max = max({nums[i], current_max*nums[i], current_min*nums[i]});\n        current_min = min({nums[i], temp*nums[i], current_min*nums[i]});\n        global_max = max(global_max, current_max);\n    }\n    return global_max;\n}\n"
      },
      "word_break": {
        "id": "word_break",
        "title": "Word Break",
        "difficulty": "medium",
        "description": "Determine if a string can be segmented into dictionary words using dynamic programming.",
        "input_format": "String s and list of words",
        "output_format": "Boolean indicating possibility",
        "constraints": [
          "1 ≤ s.length ≤ 300",
          "1 ≤ wordDict.length ≤ 1000"
        ],
        "example": {
          "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
          "output": "true",
          "explanation": "\"leet code\""
        },
        "solution_approach": "DP array where dp[i] is true if s[0..i-1] can be segmented.",
        "related_concepts": [
          "dynamic_programming",
          "substring_search"
        ],
        "cpp_solution": "\nbool wordBreak(string s, vector<string>& wordDict) {\n    unordered_set<string> dict(wordDict.begin(), wordDict.end());\n    vector<bool> dp(s.size()+1);\n    dp[0] = true;\n    \n    for(int i=1; i<=s.size(); i++)\n        for(int j=0; j<i; j++)\n            if(dp[j] && dict.count(s.substr(j,i-j))) {\n                dp[i] = true;\n                break;\n            }\n    return dp[s.size()];\n}\n"
      },
      "decode_ways": {
        "id": "decode_ways",
        "title": "Decode Ways",
        "difficulty": "medium",
        "description": "Count ways to decode a numeric string to letters (A=1, B=2,... Z=26).",
        "input_format": "String s containing digits",
        "output_format": "Integer number of ways",
        "constraints": [
          "1 ≤ s.length ≤ 100"
        ],
        "example": {
          "input": "\"226\"",
          "output": "3",
          "explanation": "\"BZ\" (2 26), \"VF\" (22 6), \"BBF\" (2 2 6)"
        },
        "solution_approach": "1D DP where dp[i] = dp[i-1] (if valid 1-digit) + dp[i-2] (if valid 2-digit).",
        "related_concepts": [
          "dynamic_programming",
          "string_parsing"
        ],
        "cpp_solution": "\nint numDecodings(string s) {\n    int n = s.size();\n    vector<int> dp(n+1);\n    dp[0] = 1;\n    dp[1] = s[0] != '0';\n    \n    for(int i=2; i<=n; i++) {\n        int one = stoi(s.substr(i-1,1));\n        int two = stoi(s.substr(i-2,2));\n        if(one >=1) dp[i] += dp[i-1];\n        if(two >=10 && two <=26) dp[i] += dp[i-2];\n    }\n    return dp[n];\n}\n"
      },
      "cherry_pickup": {
        "id": "cherry_pickup",
        "title": "Cherry Pickup",
        "difficulty": "hard",
        "description": "Collect maximum cherries from (0,0) to (n-1,n-1) and back using 3D DP.",
        "input_format": "n x n grid with cherries (1) and thorns (0)",
        "output_format": "Maximum cherries collected",
        "constraints": [
          "1 ≤ n ≤ 50"
        ],
        "example": {
          "input": "[[0,1,-1],[1,0,-1],[1,1,1]]",
          "output": "5",
          "explanation": "Path (0,0)→(0,1)→(1,1)→(2,1)→(2,2)→(1,2)→(0,1)→(0,0)"
        },
        "solution_approach": "3D DP tracking two paths simultaneously. r1 + c1 = r2 + c2.",
        "related_concepts": [
          "dynamic_programming",
          "grid_traversal"
        ],
        "cpp_solution": "\nclass Solution {\npublic:\n    int cherryPickup(vector<vector<int>>& grid) {\n        int n = grid.size();\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(n, -1)));\n        return max(0, dfs(grid, dp, 0,0,0));\n    }\n    \n    int dfs(vector<vector<int>>& grid, vector<vector<vector<int>>>& dp, int r1, int c1, int c2) {\n        int r2 = r1 + c1 - c2;\n        if(r1>=grid.size() || r2>=grid.size() || c1>=grid[0].size() || c2>=grid[0].size() || \n           grid[r1][c1]==-1 || grid[r2][c2]==-1) return -1e8;\n        if(dp[r1][c1][c2] != -1) return dp[r1][c1][c2];\n        if(r1 == grid.size()-1 && c1 == grid.size()-1) return grid[r1][c1];\n        \n        int res = grid[r1][c1];\n        if(c1 != c2) res += grid[r2][c2];\n        \n        int cur = max({\n            dfs(grid, dp, r1+1, c1, c2),\n            dfs(grid, dp, r1, c1+1, c2),\n            dfs(grid, dp, r1+1, c1, c2+1),\n            dfs(grid, dp, r1, c1+1, c2+1)\n        });\n        res += cur;\n        dp[r1][c1][c2] = res;\n        return res;\n    }\n};\n"
      },
      "burst_balloons": {
        "id": "burst_balloons",
        "title": "Burst Balloons",
        "difficulty": "hard",
        "description": "Maximize coins by bursting balloons in optimal order using interval DP.",
        "input_format": "Array of balloon values",
        "output_format": "Maximum coins",
        "constraints": [
          "1 ≤ balloons.length ≤ 500"
        ],
        "example": {
          "input": "[3,1,5,8]",
          "output": "167",
          "explanation": "Burst 1,5,3,8 → 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167"
        },
        "solution_approach": "DP[i][j] = max coins from bursting balloons i to j. Add virtual balloons at ends.",
        "related_concepts": [
          "interval_dp",
          "dynamic_programming"
        ],
        "cpp_solution": "\nint maxCoins(vector<int>& nums) {\n    int n = nums.size();\n    vector<vector<int>> dp(n+2, vector<int>(n+2));\n    vector<int> a(n+2);\n    a[0] = a[n+1] = 1;\n    for(int i=1; i<=n; i++) a[i] = nums[i-1];\n    \n    for(int len=1; len<=n; len++) {\n        for(int i=1; i+len-1 <=n; i++) {\n            int j = i+len-1;\n            for(int k=i; k<=j; k++)\n                dp[i][j] = max(dp[i][j], dp[i][k-1] + a[i-1]*a[k]*a[j+1] + dp[k+1][j]);\n        }\n    }\n    return dp[1][n];\n}\n"
      },
      "distinct_subsequences": {
        "id": "distinct_subsequences",
        "title": "Distinct Subsequences",
        "difficulty": "hard",
        "description": "Count how many times string s appears as a subsequence in string t.",
        "input_format": "Two strings s and t",
        "output_format": "Integer count",
        "constraints": [
          "1 ≤ s.length, t.length ≤ 1000"
        ],
        "example": {
          "input": "s = \"rabbbit\", t = \"rabbit\"",
          "output": "3",
          "explanation": "3 ways to delete 'b's from 'rabbbit'"
        },
        "solution_approach": "2D DP where dp[i][j] = dp[i-1][j] + (s[i-1] == t[j-1] ? dp[i-1][j-1] : 0).",
        "related_concepts": [
          "dynamic_programming",
          "string_matching"
        ],
        "cpp_solution": "\nint numDistinct(string s, string t) {\n    int m = s.size(), n = t.size();\n    vector<vector<unsigned long>> dp(m+1, vector<unsigned long>(n+1));\n    for(int i=0; i<=m; i++) dp[i][0] = 1;\n    \n    for(int i=1; i<=m; i++)\n        for(int j=1; j<=n; j++)\n            dp[i][j] = dp[i-1][j] + (s[i-1]==t[j-1] ? dp[i-1][j-1] : 0);\n    return dp[m][n];\n}\n"
  },
  "minimum_path_sum": {
      "id": "minimum_path_sum",
      "title": "Minimum Path Sum",
      "difficulty": "medium",
      "description": "Find the path from top-left to bottom-right in a grid with non-negative numbers that minimizes the sum of its values using DP with space optimization.",
      "input_format": "2D grid of integers",
      "output_format": "Integer minimum sum",
      "constraints": [
        "m == grid.length",
        "n == grid[i].length",
        "1 ≤ m, n ≤ 200"
      ],
      "example": {
        "input": "[[1,3,1],[1,5,1],[4,2,1]]",
        "output": "7",
        "explanation": "Path 1→3→1→1→1 (sum 7)"
      },
      "solution_approach": "1D DP array tracking row costs. Update each cell with min(left, current) + grid value.",
      "related_concepts": [
        "dynamic_programming",
        "space_optimization"
      ],
      "cpp_solution": "\nint minPathSum(vector<vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size();\n    vector<int> dp(n, 0);\n    dp[0] = grid[0][0];\n    for(int j=1; j<n; j++) dp[j] = dp[j-1] + grid[0][j];\n    \n    for(int i=1; i<m; i++) {\n        dp[0] += grid[i][0];\n        for(int j=1; j<n; j++)\n            dp[j] = min(dp[j], dp[j-1]) + grid[i][j];\n    }\n    return dp.back();\n}\n"
    },
    "longest_increasing_path": {
      "id": "longest_increasing_path",
      "title": "Longest Increasing Path in Matrix",
      "difficulty": "hard",
      "description": "Find the length of the longest increasing path in a matrix using DFS with memoization.",
      "input_format": "2D grid of integers",
      "output_format": "Integer maximum path length",
      "constraints": [
        "m == matrix.length",
        "1 ≤ m, n ≤ 200"
      ],
      "example": {
        "input": "[[9,9,4],[6,6,8],[2,1,1]]",
        "output": "4",
        "explanation": "Path 1→2→6→9 (length 4)"
      },
      "solution_approach": "DFS from each cell with memoization. Track longest path in all 4 directions.",
      "related_concepts": [
        "dfs",
        "memoization"
      ],
      "cpp_solution": "\nvector<vector<int>> dirs = {{-1,0},{1,0},{0,-1},{0,1}};\nint longestIncreasingPath(vector<vector<int>>& matrix) {\n    int m=matrix.size(), n=matrix[0].size();\n    vector<vector<int>> memo(m, vector<int>(n));\n    int res=0;\n    \n    function<int(int,int)> dfs = [&](int i, int j) {\n        if(memo[i][j]) return memo[i][j];\n        int max_len=1;\n        for(auto& d : dirs) {\n            int x=i+d[0], y=j+d[1];\n            if(x>=0 && y>=0 && x<m && y<n && matrix[x][y]>matrix[i][j])\n                max_len = max(max_len, 1+dfs(x,y));\n        }\n        return memo[i][j] = max_len;\n    };\n    \n    for(int i=0; i<m; i++)\n        for(int j=0; j<n; j++)\n            res = max(res, dfs(i,j));\n    return res;\n}\n"
    },
    "partition_equal_subset": {
      "id": "partition_equal_subset",
      "title": "Partition Equal Subset Sum",
      "difficulty": "medium",
      "description": "Determine if an array can be partitioned into two subsets with equal sums.",
      "input_format": "Array of integers nums",
      "output_format": "Boolean indicating possibility",
      "constraints": [
        "1 ≤ nums.length ≤ 200",
        "1 ≤ nums[i] ≤ 100"
      ],
      "example": {
        "input": "[1,5,11,5]",
        "output": "true",
        "explanation": "Partition [1,5,5] and [11]"
      },
      "solution_approach": "Subset sum problem. Check if sum/2 is achievable using boolean DP.",
      "related_concepts": [
        "subset_sum",
        "dynamic_programming"
      ],
      "cpp_solution": "\nbool canPartition(vector<int>& nums) {\n    int sum = accumulate(nums.begin(), nums.end(), 0);\n    if(sum%2) return false;\n    int target = sum/2;\n    vector<bool> dp(target+1);\n    dp[0] = true;\n    \n    for(int num : nums)\n        for(int i=target; i>=num; i--)\n            dp[i] = dp[i] || dp[i-num];\n    return dp[target];\n}\n"
    },
    "max_length_repeated_subarray": {
      "id": "max_length_repeated_subarray",
      "title": "Maximum Length of Repeated Subarray",
      "difficulty": "medium",
      "description": "Find the maximum length of a subarray that appears in both arrays using 2D DP.",
      "input_format": "Two integer arrays nums1 and nums2",
      "output_format": "Integer maximum length",
      "constraints": [
        "1 ≤ nums1.length, nums2.length ≤ 1000"
      ],
      "example": {
        "input": "nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]",
        "output": "3",
        "explanation": "Repeated subarray [3,2,1]"
      },
      "solution_approach": "2D DP table where dp[i][j] = dp[i-1][j-1] + 1 if nums1[i-1]==nums2[j-1].",
      "related_concepts": [
        "dynamic_programming",
        "longest_common_subarray"
      ],
      "cpp_solution": "\nint findLength(vector<int>& nums1, vector<int>& nums2) {\n    int m=nums1.size(), n=nums2.size(), res=0;\n    vector<vector<int>> dp(m+1, vector<int>(n+1));\n    \n    for(int i=1; i<=m; i++)\n        for(int j=1; j<=n; j++)\n            if(nums1[i-1] == nums2[j-1]) {\n                dp[i][j] = dp[i-1][j-1]+1;\n                res = max(res, dp[i][j]);\n            }\n    return res;\n}\n"
    },
    "stone_game": {
      "id": "stone_game",
      "title": "Stone Game",
      "difficulty": "medium",
      "description": "Determine if Alice can win the stone game where players take from either end of the array.",
      "input_format": "Array of integers piles",
      "output_format": "Boolean indicating Alice's win",
      "constraints": [
        "2 ≤ piles.length ≤ 500"
      ],
      "example": {
        "input": "[5,3,4,5]",
        "output": "true",
        "explanation": "Alice takes 5, Bob takes 5, Alice takes 4, Bob takes 3"
      },
      "solution_approach": "2D DP tracking score difference. dp[i][j] = max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1]).",
      "related_concepts": [
        "game_theory",
        "dynamic_programming"
      ],
      "cpp_solution": "\nbool stoneGame(vector<int>& piles) {\n    int n = piles.size();\n    vector<vector<int>> dp(n, vector<int>(n));\n    \n    for(int i=0; i<n; i++) dp[i][i] = piles[i];\n    \n    for(int len=1; len<n; len++)\n        for(int i=0; i<n-len; i++) {\n            int j = i+len;\n            dp[i][j] = max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1]);\n        }\n    return dp[0][n-1] > 0;\n}\n"
    },
    "perfect_squares": {
      "id": "perfect_squares",
      "title": "Perfect Squares",
      "difficulty": "medium",
      "description": "Find the least number of perfect square numbers that sum to n using BFS/DP.",
      "input_format": "Integer n",
      "output_format": "Integer minimum count",
      "constraints": [
        "1 ≤ n ≤ 10^4"
      ],
      "example": {
        "input": "n=12",
        "output": "3",
        "explanation": "4 + 4 + 4"
      },
      "solution_approach": "BFS level-order traversal. Each level represents count, nodes are remain values.",
      "related_concepts": [
        "bfs",
        "number_theory"
      ],
      "cpp_solution": "\nint numSquares(int n) {\n    vector<int> squares;\n    for(int i=1; i*i<=n; i++) squares.push_back(i*i);\n    \n    queue<int> q;\n    vector<bool> vis(n+1);\n    q.push(n);\n    vis[n] = true;\n    \n    for(int steps=1; !q.empty(); steps++) {\n        for(int sz=q.size(); sz>0; sz--) {\n            int num = q.front(); q.pop();\n            for(int s : squares) {\n                int next = num - s;\n                if(next < 0) break;\n                if(next == 0) return steps;\n                if(!vis[next]) {\n                    vis[next] = true;\n                    q.push(next);\n                }\n            }\n        }\n    }\n    return -1;\n}\n"
    },
    "count_vowels_permutation": {
      "id": "count_vowels_permutation",
      "title": "Count Vowels Permutation",
      "difficulty": "hard",
      "description": "Count valid strings of length n under vowel transition rules using state DP.",
      "input_format": "Integer n",
      "output_format": "Integer count modulo 1e9+7",
      "constraints": [
        "1 ≤ n ≤ 2*10^4"
      ],
      "example": {
        "input": "n=2",
        "output": "10",
        "explanation": "Each character can be followed by valid options"
      },
      "solution_approach": "Track DP states for each vowel. Update counts based on transition rules.",
      "related_concepts": [
        "dynamic_programming",
        "state_transition"
      ],
      "cpp_solution": "\nint countVowelPermutation(int n) {\n    const int MOD = 1e9+7;\n    vector<long> dp(5,1); // a,e,i,o,u\n    \n    for(int i=2; i<=n; i++) {\n        vector<long> tmp(5);\n        tmp[0] = (dp[1] + dp[2] + dp[4]) % MOD;\n        tmp[1] = (dp[0] + dp[2]) % MOD;\n        tmp[2] = (dp[1] + dp[3]) % MOD;\n        tmp[3] = dp[2];\n        tmp[4] = (dp[2] + dp[3]) % MOD;\n        dp = tmp;\n    }\n    return accumulate(dp.begin(), dp.end(), 0L) % MOD;\n}\n"
    },
    "min_difficulty_job_schedule": {
      "id": "min_difficulty_job_schedule",
      "title": "Minimum Difficulty Job Schedule",
      "difficulty": "hard",
      "description": "Schedule jobs into d days with minimum difficulty sum using partitioning DP.",
      "input_format": "Array jobDifficulty and integer d",
      "output_format": "Integer minimum difficulty",
      "constraints": [
        "1 ≤ jobs.length ≤ 300",
        "1 ≤ d ≤ 10"
      ],
      "example": {
        "input": "jobs = [6,5,4,3,2,1], d = 2",
        "output": "7",
        "explanation": "Day1: 6,5,4,3,2 (difficulty 6), Day2:1 (difficulty 1). Total 7"
      },
      "solution_approach": "DP[i][k] = min difficulty for first i jobs in k days. For each partition point j, track max(j..i).",
      "related_concepts": [
        "dynamic_programming",
        "partitioning"
      ],
      "cpp_solution": "\nint minDifficulty(vector<int>& jobs, int d) {\n    int n = jobs.size();\n    if(n < d) return -1;\n    vector<vector<int>> dp(n+1, vector<int>(d+1, 1e9));\n    dp[0][0] = 0;\n    \n    for(int i=1; i<=n; i++)\n        for(int k=1; k<=d; k++) {\n            int max_d = 0;\n            for(int j=i-1; j>=k-1; j--) {\n                max_d = max(max_d, jobs[j]);\n                dp[i][k] = min(dp[i][k], dp[j][k-1] + max_d);\n            }\n        }\n    return dp[n][d];\n}\n"
    },
    "number_music_playlists": {
      "id": "number_music_playlists",
      "title": "Number of Music Playlists",
      "difficulty": "hard",
      "description": "Count valid playlists of length L with N unique songs and K separation using combinatorial DP.",
      "input_format": "Integers n, goal, k",
      "output_format": "Integer count modulo 1e9+7",
      "constraints": [
        "0 ≤ k < n ≤ goal ≤ 100"
      ],
      "example": {
        "input": "n=3, goal=3, k=1",
        "output": "6",
        "explanation": "All permutations of 3 songs"
      },
      "solution_approach": "DP[i][j] = ways to create playlist of i songs with j unique songs. Add new or existing songs.",
      "related_concepts": [
        "combinatorics",
        "dynamic_programming"
      ],
      "cpp_solution": "\nint numMusicPlaylists(int n, int goal, int k) {\n    const int MOD = 1e9+7;\n    vector<vector<long>> dp(goal+1, vector<long>(n+1));\n    dp[0][0] = 1;\n    \n    for(int i=1; i<=goal; i++)\n        for(int j=1; j<=n; j++) {\n            dp[i][j] = (dp[i-1][j-1] * (n-j+1)) % MOD;\n            if(j > k)\n                dp[i][j] = (dp[i][j] + dp[i-1][j] * (j-k)) % MOD;\n        }\n    return dp[goal][n];\n}\n"
    },
    "max_performance_team": {
      "id": "max_performance_team",
      "title": "Maximum Performance of a Team",
      "difficulty": "hard",
      "description": "Select up to k engineers to maximize performance (sum of speeds * min efficiency) using sorting and heap.",
      "input_format": "Array of speed and efficiency pairs, integer k",
      "output_format": "Integer maximum performance",
      "constraints": [
        "1 ≤ n ≤ 10^5",
        "1 ≤ k ≤ n"
      ],
      "example": {
        "input": "n=6, speed=[2,10,3,1,5,8], efficiency=[5,4,3,9,7,2], k=2",
        "output": "60",
        "explanation": "Engineers 0 and 4: speed=2+5=7, efficiency=5 → 7*5=35"
      },
      "solution_approach": "Sort by efficiency descending. Use min-heap to track top k speeds. Update max performance.",
      "related_concepts": [
        "sorting",
        "priority_queue"
      ],
      "cpp_solution": "\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint maxPerformance(int n, vector<int>& speed, vector<int>& efficiency, int k) {\n    vector<pair<int,int>> engineers;\n    for(int i=0; i<n; i++)\n        engineers.emplace_back(efficiency[i], speed[i]);\n    sort(engineers.rbegin(), engineers.rend());\n    \n    priority_queue<int, vector<int>, greater<int>> pq;\n    long sum=0, res=0;\n    \n    for(auto& [e,s] : engineers) {\n        pq.push(s);\n        sum += s;\n        if(pq.size() > k) {\n            sum -= pq.top();\n            pq.pop();\n        }\n        res = max(res, sum * e);\n    }\n    return res % (int)(1e9+7);\n}\n"
  },
  "task_scheduler": {
      "id": "task_scheduler",
      "title": "Task Scheduler",
      "difficulty": "medium",
      "description": "Schedule tasks with cooldown periods to minimize total time. Tasks must be separated by at least n intervals if they are the same.",
      "input_format": "Array of task characters and integer cooldown n",
      "output_format": "Integer minimum intervals",
      "constraints": [
        "1 ≤ tasks.length ≤ 10^4",
        "0 ≤ n ≤ 100"
      ],
      "example": {
        "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
        "output": "8",
        "explanation": "A→B→idle→A→B→idle→A→B"
      },
      "solution_approach": "Calculate idle slots based on max frequency. Total intervals = (max_freq-1)*(n+1) + count_max_freq. Compare with tasks.length.",
      "related_concepts": [
        "greedy_scheduling",
        "frequency_counting"
      ],
      "cpp_solution": "\nint leastInterval(vector<char>& tasks, int n) {\n    vector<int> freq(26);\n    for(char c : tasks) freq[c-'A']++;\n    sort(freq.rbegin(), freq.rend());\n    \n    int max_freq = freq[0];\n    int idle = (max_freq-1)*n;\n    for(int i=1; i<26 && idle>0; i++)\n        idle -= min(max_freq-1, freq[i]);\n    return tasks.size() + max(0, idle);\n}\n"
    },
    "gas_station": {
      "id": "gas_station",
      "title": "Gas Station",
      "difficulty": "medium",
      "description": "Find starting gas station to complete circuit around all stations.",
      "input_format": "Arrays gas and cost",
      "output_format": "Integer starting index or -1",
      "constraints": [
        "n == gas.length == cost.length",
        "1 ≤ n ≤ 10^5"
      ],
      "example": {
        "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
        "output": "3",
        "explanation": "Start at index 3 with 4 gas"
      },
      "solution_approach": "Track total gas deficit. Reset start when current tank <0. Check total gas >= total cost.",
      "related_concepts": [
        "circuit_check",
        "greedy_accumulation"
      ],
      "cpp_solution": "\nint canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n    int total=0, current=0, start=0;\n    for(int i=0; i<gas.size(); i++) {\n        total += gas[i]-cost[i];\n        current += gas[i]-cost[i];\n        if(current <0) {\n            start = i+1;\n            current=0;\n        }\n    }\n    return total >=0 ? start : -1;\n}\n"
    },
    "maximum_swap": {
      "id": "maximum_swap",
      "title": "Maximum Swap",
      "difficulty": "medium",
      "description": "Swap two digits in a number to get the maximum possible value.",
      "input_format": "Integer num",
      "output_format": "Integer maximum number",
      "constraints": [
        "0 ≤ num ≤ 10^8"
      ],
      "example": {
        "input": "2736",
        "output": "7236",
        "explanation": "Swap 2 and 7"
      },
      "solution_approach": "Track last occurrence of each digit. Swap first smaller digit with largest possible later digit.",
      "related_concepts": [
        "digit_manipulation",
        "greedy_swapping"
      ],
      "cpp_solution": "\nint maximumSwap(int num) {\n    string s = to_string(num);\n    vector<int> last(10);\n    for(int i=0; i<s.size(); i++) last[s[i]-'0'] = i;\n    \n    for(int i=0; i<s.size(); i++)\n        for(int d=9; d>s[i]-'0'; d--)\n            if(last[d] > i) {\n                swap(s[i], s[last[d]]);\n                return stoi(s);\n            }\n    return num;\n}\n"
    },
    "candy": {
      "id": "candy",
      "title": "Candy",
      "difficulty": "hard",
      "description": "Assign candies to children with higher ratings than neighbors using two-pass greedy approach.",
      "input_format": "Array of ratings",
      "output_format": "Integer minimum candies",
      "constraints": [
        "1 ≤ ratings.length ≤ 2*10^4"
      ],
      "example": {
        "input": "[1,0,2]",
        "output": "5",
        "explanation": "Candies [2,1,2]"
      },
      "solution_approach": "Left-to-right pass for left neighbors, right-to-left pass for right neighbors. Sum max values.",
      "related_concepts": [
        "two_pass_greedy",
        "array_manipulation"
      ],
      "cpp_solution": "\nint candy(vector<int>& ratings) {\n    int n = ratings.size();\n    vector<int> candies(n,1);\n    \n    for(int i=1; i<n; i++)\n        if(ratings[i] > ratings[i-1]) candies[i] = candies[i-1]+1;\n    \n    for(int i=n-2; i>=0; i--)\n        if(ratings[i] > ratings[i+1]) candies[i] = max(candies[i], candies[i+1]+1);\n    \n    return accumulate(candies.begin(), candies.end(),0);\n}\n"
    },
    "reorganize_string": {
      "id": "reorganize_string",
      "title": "Reorganize String",
      "difficulty": "medium",
      "description": "Rearrange characters so no two adjacent are the same. Return any valid arrangement.",
      "input_format": "String s",
      "output_format": "Rearranged string or empty",
      "constraints": [
        "1 ≤ s.length ≤ 500"
      ],
      "example": {
        "input": "\"aab\"",
        "output": "\"aba\"",
        "explanation": "Valid rearrangement"
      },
      "solution_approach": "Use max-heap to always pick two most frequent characters. Interleave them.",
      "related_concepts": [
        "max_heap",
        "frequency_counting"
      ],
      "cpp_solution": "\nstring reorganizeString(string s) {\n    vector<int> freq(26);\n    for(char c : s) freq[c-'a']++;\n    \n    priority_queue<pair<int,char>> pq;\n    for(int i=0; i<26; i++)\n        if(freq[i]>0) pq.push({freq[i], 'a'+i});\n    \n    string res;\n    while(pq.size() >=2) {\n        auto [f1,c1] = pq.top(); pq.pop();\n        auto [f2,c2] = pq.top(); pq.pop();\n        res += c1; res += c2;\n        if(--f1>0) pq.push({f1,c1});\n        if(--f2>0) pq.push({f2,c2});\n    }\n    \n    if(!pq.empty()) {\n        if(pq.top().first >1) return \"\";\n        res += pq.top().second;\n    }\n    return res;\n}\n"
    },
    "minimum_domino_rotations": {
      "id": "minimum_domino_rotations",
      "title": "Minimum Domino Rotations",
      "difficulty": "medium",
      "description": "Find minimum rotations to make all values in tops or bottoms the same.",
      "input_format": "Two arrays tops and bottoms",
      "output_format": "Integer minimum rotations or -1",
      "constraints": [
        "1 ≤ tops.length ≤ 2*10^4"
      ],
      "example": {
        "input": "tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]",
        "output": "2",
        "explanation": "Rotate tops[0] and bottoms[3] to make all tops 2"
      },
      "solution_approach": "Check candidates from first elements of both arrays. Count swaps needed for each candidate.",
      "related_concepts": [
        "candidate_checking",
        "array_manipulation"
      ],
      "cpp_solution": "\nint minDominoRotations(vector<int>& tops, vector<int>& bottoms) {\n    auto check = [&](int x) {\n        int rotTop=0, rotBot=0;\n        for(int i=0; i<tops.size(); i++) {\n            if(tops[i]!=x && bottoms[i]!=x) return -1;\n            if(tops[i]!=x) rotTop++;\n            if(bottoms[i]!=x) rotBot++;\n        }\n        return min(rotTop, rotBot);\n    };\n    \n    int res = check(tops[0]);\n    if(res != -1) return res;\n    return check(bottoms[0]);\n}\n"
    },
    "video_stitching": {
      "id": "video_stitching",
      "title": "Video Stitching",
      "difficulty": "medium",
      "description": "Find minimum number of clips to cover interval [0, time].",
      "input_format": "Array of clips [start,end], integer time",
      "output_format": "Integer count or -1",
      "constraints": [
        "1 ≤ clips.length ≤ 100"
      ],
      "example": {
        "input": "[[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time=10",
        "output": "3",
        "explanation": "Clips [0,2] + [1,9] + [8,10]"
      },
      "solution_approach": "Sort clips by start time. Greedily extend end as far as possible each step.",
      "related_concepts": [
        "interval_scheduling",
        "greedy_selection"
      ],
      "cpp_solution": "\nint videoStitching(vector<vector<int>>& clips, int time) {\n    sort(clips.begin(), clips.end());\n    int end=0, far=0, res=0, i=0;\n    \n    while(end < time) {\n        while(i<clips.size() && clips[i][0] <= end)\n            far = max(far, clips[i++][1]);\n        if(end == far) return -1;\n        end = far;\n        res++;\n    }\n    return res;\n}\n"
    },
    "boats_to_save_people": {
      "id": "boats_to_save_people",
      "title": "Boats to Save People",
      "difficulty": "medium",
      "description": "Find minimum boats to carry people with weight limit. Each boat carries at most two.",
      "input_format": "Array of weights, integer limit",
      "output_format": "Integer minimum boats",
      "constraints": [
        "1 ≤ people.length ≤ 5*10^4"
      ],
      "example": {
        "input": "[3,2,2,1], limit=3",
        "output": "3",
        "explanation": "1+3, 2+1, 2"
      },
      "solution_approach": "Sort array. Two pointers from ends. Pair heaviest + lightest if possible.",
      "related_concepts": [
        "two_pointers",
        "sorting"
      ],
      "cpp_solution": "\nint numRescueBoats(vector<int>& people, int limit) {\n    sort(people.begin(), people.end());\n    int left=0, right=people.size()-1, boats=0;\n    while(left <= right) {\n        if(people[left] + people[right] <= limit) left++;\n        right--;\n        boats++;\n    }\n    return boats;\n}\n"
    },
    "remove_k_digits": {
      "id": "remove_k_digits",
      "title": "Remove K Digits",
      "difficulty": "medium",
      "description": "Remove k digits to form the smallest possible number using monotonic stack.",
      "input_format": "String num and integer k",
      "output_format": "String result",
      "constraints": [
        "1 ≤ k ≤ num.length ≤ 10^5"
      ],
      "example": {
        "input": "\"1432219\", k=3",
        "output": "\"1219\"",
        "explanation": "Remove 4,3,2 → 1219"
      },
      "solution_approach": "Maintain monotonic increasing stack. Remove larger preceding digits when possible.",
      "related_concepts": [
        "monotonic_stack",
        "string_manipulation"
      ],
      "cpp_solution": "\nstring removeKdigits(string num, int k) {\n    string res;\n    for(char c : num) {\n        while(k>0 && !res.empty() && res.back()>c) {\n            res.pop_back();\n            k--;\n        }\n        res.push_back(c);\n    }\n    while(k-- >0) res.pop_back();\n    res.erase(0, res.find_first_not_of('0'));\n    return res.empty() ? \"0\" : res;\n}\n"
    },
    "valid_parenthesis_string": {
      "id": "valid_parenthesis_string",
      "title": "Valid Parenthesis String",
      "difficulty": "medium",
      "description": "Check if string with wildcards (*) can form valid parentheses using greedy balance tracking.",
      "input_format": "String s with '(', ')', '*'",
      "output_format": "Boolean validity",
      "constraints": [
        "1 ≤ s.length ≤ 100"
      ],
      "example": {
        "input": "\"(*))\"",
        "output": "true",
        "explanation": "Replace * with '(' → \"(())\""
      },
      "solution_approach": "Track possible min and max open counts. * can be '(', ')', or empty.",
      "related_concepts": [
        "balance_tracking",
        "greedy_ranges"
      ],
      "cpp_solution": "\nbool checkValidString(string s) {\n    int low=0, high=0;\n    for(char c : s) {\n        low += c == '(' ? 1 : -1;\n        high += c != ')' ? 1 : -1;\n        if(high <0) break;\n        low = max(low,0);\n    }\n    return low ==0;\n}\n"
    },
    "jump_game_ii": {
      "id": "jump_game_ii",
      "title": "Jump Game II",
      "difficulty": "medium",
      "description": "Find minimum jumps to reach the end of the array using greedy BFS-like approach.",
      "input_format": "Array of jump lengths",
      "output_format": "Integer minimum jumps",
      "constraints": [
        "1 ≤ nums.length ≤ 10^4"
      ],
      "example": {
        "input": "[2,3,1,1,4]",
        "output": "2",
        "explanation": "Jump from index 0→1→4"
      },
      "solution_approach": "Track current and farthest reach. Increment jumps when current end is reached.",
      "related_concepts": [
        "greedy_bfs",
        "array_traversal"
      ],
      "cpp_solution": "\nint jump(vector<int>& nums) {\n    int jumps=0, current_end=0, farthest=0;\n    for(int i=0; i<nums.size()-1; i++) {\n        farthest = max(farthest, i+nums[i]);\n        if(i == current_end) {\n            jumps++;\n            current_end = farthest;\n        }\n    }\n    return jumps;\n}\n"
    },
    "patching_array": {
      "id": "patching_array",
      "title": "Patching Array",
      "difficulty": "hard",
      "description": "Find minimum numbers to add to array to cover [1,n] using greedy number coverage.",
      "input_format": "Sorted array nums and integer n",
      "output_format": "Integer minimum patches",
      "constraints": [
        "1 ≤ nums.length ≤ 1000"
      ],
      "example": {
        "input": "nums = [1,3], n=6",
        "output": "1",
        "explanation": "Add 2 to cover [1,2,3,4,5,6]"
      },
      "solution_approach": "Track covered range. Add missing numbers when current nums[i] > covered+1.",
      "related_concepts": [
        "number_coverage",
        "greedy_addition"
      ],
      "cpp_solution": "\nint minPatches(vector<int>& nums, int n) {\n    long covered=0, patches=0, i=0;\n    while(covered < n) {\n        if(i<nums.size() && nums[i] <= covered+1)\n            covered += nums[i++];\n        else {\n            covered += covered+1;\n            patches++;\n        }\n    }\n    return patches;\n}\n"
    },
    "min_deletions_char_freq": {
      "id": "min_deletions_char_freq",
      "title": "Minimum Deletions for Character Frequencies",
      "difficulty": "medium",
      "description": "Find minimum deletions to make all character frequencies unique.",
      "input_format": "String s",
      "output_format": "Integer deletions",
      "constraints": [
        "1 ≤ s.length ≤ 10^5"
      ],
      "example": {
        "input": "\"aaabbbcc\"",
        "output": "2",
        "explanation": "Delete one 'a' and one 'b' → frequencies [3,2,2] → [3,2,1]"
      },
      "solution_approach": "Sort frequencies descending. Ensure each is less than previous, adjusting deletions.",
      "related_concepts": [
        "frequency_sorting",
        "greedy_decrements"
      ],
      "cpp_solution": "\nint minDeletions(string s) {\n    vector<int> freq(26);\n    for(char c : s) freq[c-'a']++;\n    sort(freq.rbegin(), freq.rend());\n    \n    int del=0, prev=freq[0];\n    for(int i=1; i<26 && freq[i]>0; i++) {\n        prev = max(0, min(freq[i], prev-1));\n        del += freq[i] - prev;\n    }\n    return del;\n}\n"
    },
    "largest_merge_two_strings": {
      "id": "largest_merge_two_strings",
      "title": "Largest Merge of Two Strings",
      "difficulty": "medium",
      "description": "Merge two strings lexicographically to form the largest possible string.",
      "input_format": "Two strings word1 and word2",
      "output_format": "Merged string",
      "constraints": [
        "1 ≤ word1.length, word2.length ≤ 3000"
      ],
      "example": {
        "input": "\"cabaa\", \"bcaaa\"",
        "output": "\"cbcabaaaaa\"",
        "explanation": "Lexicographically largest possible merge"
      },
      "solution_approach": "Compare remaining substrings at each step. Choose the larger current option.",
      "related_concepts": [
        "lexicographical_order",
        "two_pointers"
      ],
      "cpp_solution": "\nstring largestMerge(string a, string b) {\n    string res;\n    int i=0, j=0;\n    while(i < a.size() || j < b.size()) {\n        if(a.substr(i) > b.substr(j))\n            res += a[i++];\n        else\n            res += b[j++];\n    }\n    return res;\n}\n"
    },
    "max_number_events": {
      "id": "max_number_events",
      "title": "Maximum Number of Events",
      "difficulty": "medium",
      "description": "Attend maximum events using priority queue for earliest ending events.",
      "input_format": "Array of events [start_day, end_day]",
      "output_format": "Integer maximum events",
      "constraints": [
        "1 ≤ events.length ≤ 10^5"
      ],
      "example": {
        "input": "[[1,2],[2,3],[3,4]]",
        "output": "3",
        "explanation": "Attend all three events"
      },
      "solution_approach": "Sort events by start day. Use min-heap to track end days. Remove expired events each day.",
      "related_concepts": [
        "priority_queue",
        "interval_scheduling"
      ],
      "cpp_solution": "\nint maxEvents(vector<vector<int>>& events) {\n    sort(events.begin(), events.end());\n    priority_queue<int, vector<int>, greater<int>> pq;\n    int day=0, res=0, n=events.size(), i=0;\n    \n    while(i<n || !pq.empty()) {\n        if(pq.empty()) day = events[i][0];\n        while(i<n && events[i][0] <= day)\n            pq.push(events[i++][1]);\n        pq.pop();\n        res++;\n        day++;\n        while(!pq.empty() && pq.top() < day) pq.pop();\n    }\n    return res;\n}\n"
    },
  "kth_largest_element": {
        "id": "kth_largest_element",
        "title": "Kth Largest Element in Array",
        "difficulty": "medium",
        "description": "Find the kth largest element in an unsorted array using Quickselect algorithm.",
        "input_format": "Array of integers nums, integer k",
        "output_format": "Integer kth largest element",
        "constraints": [
          "1 ≤ k ≤ nums.length ≤ 10^4",
          "-10^4 ≤ nums[i] ≤ 10^4"
        ],
        "example": {
          "input": "nums = [3,2,1,5,6,4], k = 2",
          "output": "5",
          "explanation": "Second largest element is 5"
        },
        "solution_approach": "Partition array using Lomuto scheme. Recurse on partition with kth element.",
        "related_concepts": [
          "quickselect",
          "partitioning"
        ],
        "cpp_solution": "\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint quickselect(vector<int>& nums, int l, int r, int k) {\n    int pivot = nums[r];\n    int p = l;\n    for(int i=l; i<r; i++)\n        if(nums[i] <= pivot) swap(nums[p++], nums[i]);\n    swap(nums[p], nums[r]);\n    \n    int count = r - p + 1;\n    if(count == k) return nums[p];\n    if(count > k) return quickselect(nums, p+1, r, k);\n    return quickselect(nums, l, p-1, k - count);\n}\n\nint findKthLargest(vector<int>& nums, int k) {\n    return quickselect(nums, 0, nums.size()-1, k);\n}\n"
      },
      "closest_pair_points": {
        "id": "closest_pair_points",
        "title": "Closest Pair of Points",
        "difficulty": "hard",
        "description": "Find the closest pair of points in a 2D plane using divide and conquer.",
        "input_format": "List of (x,y) coordinate pairs",
        "output_format": "Minimum Euclidean distance",
        "constraints": [
          "2 ≤ n ≤ 10^4",
          "-10^4 ≤ x,y ≤ 10^4"
        ],
        "example": {
          "input": "[(0,0), (1,1), (1,2)]",
          "output": "1.41421",
          "explanation": "Closest pair is (0,0)-(1,1) with distance √2"
        },
        "solution_approach": "1. Sort by x-coordinate 2. Split into left/right 3. Check strip of δ-width",
        "related_concepts": [
          "geometry",
          "recursive_splitting"
        ],
        "cpp_solution": "\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\ntypedef pair<double,double> Point;\n\ndouble dist(Point a, Point b) {\n    return hypot(a.first-b.first, a.second-b.second);\n}\n\ndouble stripClosest(vector<Point> strip, double d) {\n    double min_dist = d;\n    sort(strip.begin(), strip.end(), [](auto& a, auto& b){return a.second < b.second;});\n    for(int i=0; i<strip.size(); i++)\n        for(int j=i+1; j<strip.size() && (strip[j].second - strip[i].second) < min_dist; j++)\n            min_dist = min(min_dist, dist(strip[i], strip[j]));\n    return min_dist;\n}\n\ndouble closestUtil(vector<Point>& points, int l, int r) {\n    if(r-l <=3) {\n        double min_dist = DBL_MAX;\n        for(int i=l; i<=r; i++)\n            for(int j=i+1; j<=r; j++)\n                min_dist = min(min_dist, dist(points[i], points[j]));\n        return min_dist;\n    }\n    \n    int mid = (l+r)/2;\n    double dl = closestUtil(points, l, mid);\n    double dr = closestUtil(points, mid+1, r);\n    double d = min(dl, dr);\n    \n    vector<Point> strip;\n    for(int i=l; i<=r; i++)\n        if(abs(points[i].first - points[mid].first) < d)\n            strip.push_back(points[i]);\n    return min(d, stripClosest(strip, d));\n}\n\ndouble closestPair(vector<Point>& points) {\n    sort(points.begin(), points.end());\n    return closestUtil(points, 0, points.size()-1);\n}\n"
      },
      "different_ways_add_parentheses": {
        "id": "different_ways_add_parentheses",
        "title": "Different Ways to Add Parentheses",
        "difficulty": "medium",
        "description": "Compute all possible results from adding parentheses to an arithmetic expression.",
        "input_format": "String expression of digits and operators",
        "output_format": "List of possible results",
        "constraints": [
          "1 ≤ expression.length ≤ 20",
          "Valid operators: +, -, *"
        ],
        "example": {
          "input": "\"2-1-1\"",
          "output": "[0, 2]",
          "explanation": "((2-1)-1)=0, (2-(1-1))=2"
        },
        "solution_approach": "Split at each operator, recursively compute left/right results, combine.",
        "related_concepts": [
          "expression_parsing",
          "recursive_splitting"
        ],
        "cpp_solution": "\nvector<int> diffWaysToCompute(string expr) {\n    vector<int> res;\n    for(int i=0; i<expr.size(); i++) {\n        if(ispunct(expr[i])) {\n            auto left = diffWaysToCompute(expr.substr(0,i));\n            auto right = diffWaysToCompute(expr.substr(i+1));\n            for(int l : left) for(int r : right) {\n                if(expr[i]=='+') res.push_back(l+r);\n                else if(expr[i]=='-') res.push_back(l-r);\n                else res.push_back(l*r);\n            }\n        }\n    }\n    return res.empty() ? vector<int>{stoi(expr)} : res;\n}\n"
      },
    "maximum_subarray_divide_and_conquer": {
        "id": "maximum_subarray_divide_and_conquer",
        "title": "Maximum Subarray (Divide & Conquer)",
        "difficulty": "medium",
        "description": "Find the contiguous subarray with maximum sum using divide and conquer approach.",
        "input_format": "Array of integers nums",
        "output_format": "Integer maximum sum",
        "constraints": [
          "1 ≤ nums.length ≤ 10^5",
          "-10^4 ≤ nums[i] ≤ 10^4"
        ],
        "example": {
          "input": "[-2,1,-3,4,-1,2,1,-5,4]",
          "output": "6",
          "explanation": "Subarray [4,-1,2,1] has sum 6"
        },
        "solution_approach": "Split array, compute max in left/right/crossing subarrays. Return maximum of three.",
        "related_concepts": [
          "subarray_sums",
          "recursive_splitting"
        ],
        "cpp_solution": "\nint maxCrossing(vector<int>& nums, int l, int m, int r) {\n    int left_sum = INT_MIN, sum=0;\n    for(int i=m; i>=l; i--) {\n        sum += nums[i];\n        left_sum = max(left_sum, sum);\n    }\n    int right_sum = INT_MIN; sum=0;\n    for(int i=m+1; i<=r; i++) {\n        sum += nums[i];\n        right_sum = max(right_sum, sum);\n    }\n    return left_sum + right_sum;\n}\n\nint maxSubArrayDC(vector<int>& nums, int l, int r) {\n    if(l == r) return nums[l];\n    int m = l + (r-l)/2;\n    return max({maxSubArrayDC(nums,l,m), \n               maxSubArrayDC(nums,m+1,r), \n               maxCrossing(nums,l,m,r)});\n}\n\nint maxSubArray(vector<int>& nums) {\n    return maxSubArrayDC(nums, 0, nums.size()-1);\n}\n"
      },
      "count_range_sum": {
        "id": "count_range_sum",
        "title": "Count of Range Sum",
        "difficulty": "hard",
        "description": "Count the number of range sums [i,j] that lie in [lower, upper] using merge sort variant.",
        "input_format": "Array nums, integers lower and upper",
        "output_format": "Integer count",
        "constraints": [
          "1 ≤ nums.length ≤ 10^4",
          "-10^5 ≤ nums[i] ≤ 10^5"
        ],
        "example": {
          "input": "nums = [-2,5,-1], lower = -2, upper = 2",
          "output": "3",
          "explanation": "Sums: [0,1], [2,3], [0,2]"
        },
        "solution_approach": "Compute prefix sums. During merge sort, count valid ranges using two pointers.",
        "related_concepts": [
          "prefix_sum",
          "merge_sort_variant"
        ],
        "cpp_solution": "\nint countRangeSum(vector<int>& nums, int lower, int upper) {\n    vector<long> prefix(nums.size()+1);\n    for(int i=0; i<nums.size(); i++)\n        prefix[i+1] = prefix[i] + nums[i];\n    \n    function<int(int,int)> mergeSort = [&](int l, int r) {\n        if(l >= r) return 0;\n        int m = l + (r-l)/2;\n        int count = mergeSort(l,m) + mergeSort(m+1,r);\n        \n        int i = m+1, j = m+1;\n        for(int k=l; k<=m; k++) {\n            while(i <= r && prefix[i] - prefix[k] < lower) i++;\n            while(j <= r && prefix[j] - prefix[k] <= upper) j++;\n            count += j - i;\n        }\n        inplace_merge(prefix.begin()+l, prefix.begin()+m+1, prefix.begin()+r+1);\n        return count;\n    };\n    return mergeSort(0, prefix.size()-1);\n}\n"
      },
      "majority_element_dc": {
        "id": "majority_element_dc",
        "title": "Majority Element (Divide & Conquer)",
        "difficulty": "easy",
        "description": "Find the majority element (appears > ⌊n/2⌋ times) using divide and conquer.",
        "input_format": "Array of integers nums",
        "output_format": "Integer majority element",
        "constraints": [
          "1 ≤ nums.length ≤ 5*10^4",
          "-10^9 ≤ nums[i] ≤ 10^9"
        ],
        "example": {  
          "input": "[3,2,3]",
          "output": "3",
          "explanation": "3 appears 2/3 times"
        },
        "solution_approach": "Split array, find majority in halves. Verify candidate in entire array.",
        "related_concepts": [
          "majority_vote",
          "recursive_verification"
        ],
        "cpp_solution": "\nint majorityElement(vector<int>& nums, int l=0, int r=-1) {\n    if(r == -1) r = nums.size()-1;\n    if(l == r) return nums[l];\n    \n    int m = l + (r-l)/2;\n    int left = majorityElement(nums, l, m);\n    int right = majorityElement(nums, m+1, r);\n    \n    if(left == right) return left;\n    \n    int count_left = count(nums.begin()+l, nums.begin()+r+1, left);\n    int count_right = count(nums.begin()+l, nums.begin()+r+1, right);\n    return count_left > count_right ? left : right;\n}\n"
      },
      "matrix_multiplication_strassen": {
        "id": "matrix_multiplication_strassen",
        "title": "Matrix Multiplication (Strassen's Algorithm)",
        "difficulty": "medium",
        "description": "Multiply two matrices using Strassen's divide and conquer algorithm.",
        "input_format": "Two n x n matrices",
        "output_format": "Resultant matrix",
        "constraints": [
          "n is a power of 2",
          "1 ≤ n ≤ 64"
        ],
        "example": {
          "input": "A=[[1,2],[3,4]], B=[[5,6],[7,8]]",
          "output": "[[19,22],[43,50]]",
          "explanation": "Standard matrix multiplication result"
        },
        "solution_approach": "Split matrices into submatrices. Compute 7 products recursively. Combine results.",
        "related_concepts": [
          "matrix_operations",
          "submatrix_recursion"
        ],
        "cpp_solution": "\n// Base case for 2x2 matrices omitted for brevity\nvector<vector<int>> strassenMultiply(vector<vector<int>>& A, vector<vector<int>>& B) {\n    int n = A.size();\n    if(n == 1) return {{A[0][0] * B[0][0]}};\n    \n    // Split matrices into quadrants (code omitted)\n    // Compute 7 Strassen products recursively\n    // Combine products into result matrix\n    return result;\n}\n"
      },
      "longest_common_prefix_dc": {
        "id": "longest_common_prefix_dc",
        "title": "Longest Common Prefix (Divide & Conquer)",
        "difficulty": "easy",
        "description": "Find the longest common prefix string using divide and conquer approach.",
        "input_format": "Array of strings",
        "output_format": "Common prefix string",
        "constraints": [
          "1 ≤ strs.length ≤ 200",
          "0 ≤ strs[i].length ≤ 200"
        ],
        "example": {
          "input": "[\"flower\",\"flow\",\"flight\"]",
          "output": "\"fl\"",
          "explanation": "All strings start with 'fl'"
        },
        "solution_approach": "Split array into halves. Find LCP of left and right halves.",
        "related_concepts": [
          "string_comparison",
          "recursive_splitting"
        ],
        "cpp_solution": "\nstring commonPrefix(string a, string b) {\n    int i=0;\n    while(i < a.size() && i < b.size() && a[i]==b[i]) i++;\n    return a.substr(0,i);\n}\n\nstring longestCommonPrefix(vector<string>& strs, int l=0, int r=-1) {\n    if(r == -1) r = strs.size()-1;\n    if(l == r) return strs[l];\n    \n    int m = l + (r-l)/2;\n    string left = longestCommonPrefix(strs, l, m);\n    string right = longestCommonPrefix(strs, m+1, r);\n    return commonPrefix(left, right);\n}\n"
      },
      "reverse_pairs": {
        "id": "reverse_pairs",
        "title": "Reverse Pairs",
        "difficulty": "hard",
        "description": "Count reverse pairs (i < j and nums[i] > 2*nums[j]) using modified merge sort.",
        "input_format": "Array of integers nums",
        "output_format": "Integer count",
        "constraints": [
          "1 ≤ nums.length ≤ 5*10^4",
          "-10^4 ≤ nums[i] ≤ 10^4"
        ],
        "example": {
          "input": "[1,3,2,3,1]",
          "output": "2",
          "explanation": "Pairs (3,1) and (3,1) at indices (1,4) and (3,4)"
        },
        "solution_approach": "During merge sort, count pairs where left[i] > 2*right[j] before merging.",
        "related_concepts": [
          "inversion_count",
          "merge_sort_modification"
        ],
        "cpp_solution": "\nint reversePairs(vector<int>& nums) {\n    int count = 0;\n    function<void(int,int)> mergeSort = [&](int l, int r) {\n        if(l >= r) return;\n        int m = l + (r-l)/2;\n        mergeSort(l, m);\n        mergeSort(m+1, r);\n        \n        // Count reverse pairs\n        int i=l, j=m+1;\n        while(i <= m) {\n            while(j <= r && nums[i] > 2L*nums[j]) j++;\n            count += j - (m+1);\n            i++;\n        }\n        // Merge step\n        inplace_merge(nums.begin()+l, nums.begin()+m+1, nums.begin()+r+1);\n    };\n    mergeSort(0, nums.size()-1);\n    return count;\n}\n"
      },
      "median_two_arrays": {
        "id": "median_two_arrays",
        "title": "Median of Two Sorted Arrays",
        "difficulty": "hard",
        "description": "Find the median of two sorted arrays using binary search partitioning.",
        "input_format": "Two sorted arrays nums1 and nums2",
        "output_format": "Double median value",
        "constraints": [
          "nums1.length + nums2.length ≥ 1",
          "nums1 and nums2 are sorted"
        ],
        "example": {
          "input": "nums1 = [1,3], nums2 = [2]",
          "output": "2.0",
          "explanation": "Merged array [1,2,3], median 2"
        },
        "solution_approach": "Partition both arrays to ensure left elements ≤ right elements. Adjust partitions using binary search.",
        "related_concepts": [
          "binary_search",
          "array_partitioning"
        ],
        "cpp_solution": "\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n    if(nums1.size() > nums2.size()) swap(nums1, nums2);\n    int m = nums1.size(), n = nums2.size();\n    int l=0, r=m;\n    \n    while(l <= r) {\n        int i = (l+r)/2;\n        int j = (m+n+1)/2 - i;\n        \n        int left1 = i==0 ? INT_MIN : nums1[i-1];\n        int left2 = j==0 ? INT_MIN : nums2[j-1];\n        int right1 = i==m ? INT_MAX : nums1[i];\n        int right2 = j==n ? INT_MAX : nums2[j];\n        \n        if(left1 <= right2 && left2 <= right1) {\n            if((m+n)%2) return max(left1, left2);\n            return (max(left1, left2) + min(right1, right2)) / 2.0;\n        }\n        else if(left1 > right2) r = i-1;\n        else l = i+1;\n    }\n    return 0.0;\n}\n"
  },
  "strstr_kmp": {
      "id": "strstr_kmp",
      "title": "Implement strStr()",
      "difficulty": "easy",
      "description": "Find the index of the first occurrence of a substring in a string using KMP algorithm.",
      "input_format": "Two strings haystack and needle",
      "output_format": "Integer index or -1",
      "constraints": [
        "0 ≤ haystack.length, needle.length ≤ 10^4",
        "Needle is an empty string → return 0"
      ],
      "example": {
        "input": "haystack = \"hello\", needle = \"ll\"",
        "output": "2",
        "explanation": "First occurrence starts at index 2"
      },
      "solution_approach": "Build KMP prefix array for pattern. Traverse text with pattern pointers.",
      "related_concepts": [
        "kmp_algorithm",
        "prefix_function"
      ],
      "cpp_solution": "\nint strStr(string haystack, string needle) {\n    if(needle.empty()) return 0;\n    vector<int> lps(needle.size(),0);\n    for(int i=1,j=0; i<needle.size();){\n        if(needle[i]==needle[j]) lps[i++]=++j;\n        else j ? j=lps[j-1] : i++;\n    }\n    for(int i=0,j=0; i<haystack.size();){\n        if(haystack[i]==needle[j]) i++,j++;\n        if(j==needle.size()) return i-j;\n        if(i<haystack.size() && haystack[i]!=needle[j])\n            j ? j=lps[j-1] : i++;\n    }\n    return -1;\n}\n"
    },
    "repeated_dna_sequences": {
      "id": "repeated_dna_sequences",
      "title": "Repeated DNA Sequences",
      "difficulty": "medium",
      "description": "Find all 10-letter sequences occurring more than once in a DNA string using rolling hash.",
      "input_format": "String s",
      "output_format": "List of repeated sequences",
      "constraints": [
        "0 ≤ s.length ≤ 10^5"
      ],
      "example": {
        "input": "\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"",
        "output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
        "explanation": "Two repeated 10-mer sequences"
      },
      "solution_approach": "Use hash set to track seen sequences. Rolling hash for O(n) time complexity.",
      "related_concepts": [
        "rolling_hash",
        "substring_search"
      ],
      "cpp_solution": "\nvector<string> findRepeatedDnaSequences(string s) {\n    unordered_set<string> seen, res;\n    for(int i=0; i+10<=s.size(); i++){\n        string seq = s.substr(i,10);\n        if(seen.count(seq)) res.insert(seq);\n        else seen.insert(seq);\n    }\n    return vector<string>(res.begin(),res.end());\n}\n"
    },
    "palindrome_permutation": {
      "id": "palindrome_permutation",
      "title": "Palindrome Permutation",
      "difficulty": "easy",
      "description": "Check if a string can be rearranged into a palindrome using frequency counting.",
      "input_format": "String s",
      "output_format": "Boolean indicating possibility",
      "constraints": [
        "1 ≤ s.length ≤ 5000"
      ],
      "example": {
        "input": "\"code\"",
        "output": "false",
        "explanation": "No palindrome permutation possible"
      },
      "solution_approach": "Count character frequencies. At most one character can have odd count.",
      "related_concepts": [
        "frequency_count",
        "palindrome_properties"
      ],
      "cpp_solution": "\nbool canPermutePalindrome(string s) {\n    vector<int> cnt(128);\n    for(char c:s) cnt[c]++;\n    int odd=0;\n    for(int n:cnt) odd += n%2;\n    return odd <=1;\n}\n"
    },
    "smallest_rotation_score": {
      "id": "smallest_rotation_score",
      "title": "Smallest Rotation with Highest Score",
      "difficulty": "hard",
      "description": "Find rotation k where elements <= their index yields maximum score. Return smallest k.",
      "input_format": "Array of integers nums",
      "output_format": "Integer rotation value",
      "constraints": [
        "1 ≤ nums.length ≤ 10^5",
        "0 ≤ nums[i] < nums.length"
      ],
      "example": {
        "input": "[2,3,1,4,0]",
        "output": "3",
        "explanation": "Rotation k=3 gives maximum score"
      },
      "solution_approach": "Track valid rotation ranges. Use difference array to find optimal k.",
      "related_concepts": [
        "mathematical_patterns",
        "difference_array"
      ],
      "cpp_solution": "\nint bestRotation(vector<int>& nums) {\n    int n=nums.size();\n    vector<int> change(n);\n    for(int i=0;i<n;i++){\n        int l=(i-nums[i]+1+n)%n;\n        int r=(i+1)%n;\n        change[l]--;\n        change[r]++;\n        if(l>r) change[0]--;\n    }\n    int max_score=change[0], res=0, score=change[0];\n    for(int k=1;k<n;k++){\n        score += change[k];\n        if(score>max_score) max_score=score,res=k;\n    }\n    return res;\n}\n"
    },
    "longest_happy_prefix": {
      "id": "longest_happy_prefix",
      "title": "Longest Happy Prefix",
      "difficulty": "hard",
      "description": "Find the longest prefix which is also a suffix using KMP failure function.",
      "input_format": "String s",
      "output_format": "Longest happy prefix",
      "constraints": [
        "1 ≤ s.length ≤ 10^5"
      ],
      "example": {
        "input": "\"ababab\"",
        "output": "\"abab\"",
        "explanation": "Longest prefix-suffix match is 'abab'"
      },
      "solution_approach": "Build KMP prefix array. Return longest prefix of length lps[-1].",
      "related_concepts": [
        "kmp_failure_function",
        "prefix_suffix_matching"
      ],
      "cpp_solution": "\nstring longestPrefix(string s) {\n    vector<int> lps(s.size(),0);\n    for(int i=1,j=0; i<s.size();){\n        if(s[i]==s[j]) lps[i++]=++j;\n        else j ? j=lps[j-1] : i++;\n    }\n    return s.substr(0,lps.back());\n}\n"
    },
    "rabin_karp": {
      "id": "rabin_karp",
      "title": "Rabin-Karp Fingerprint",
      "difficulty": "medium",
      "description": "Implement substring search using Rabin-Karp algorithm with collision handling.",
      "input_format": "Strings text and pattern",
      "output_format": "First occurrence index or -1",
      "constraints": [
        "1 ≤ text.length, pattern.length ≤ 10^4"
      ],
      "example": {
        "input": "text = \"hello\", pattern = \"ll\"",
        "output": "2",
        "explanation": "Pattern found at index 2"
      },
      "solution_approach": "Compute rolling hash for pattern and text windows. Verify hash matches with string comparison.",
      "related_concepts": [
        "rolling_hash",
        "collision_handling"
      ],
      "cpp_solution": "\nconst int BASE = 256, MOD = 1e9+7;\n\nint rabinKarp(string text, string pattern) {\n    int n=text.size(), m=pattern.size();\n    if(m>n) return -1;\n    \n    int h=1, patHash=0, txtHash=0;\n    for(int i=0;i<m-1;i++) h=(h*BASE)%MOD;\n    for(int i=0;i<m;i++){\n        patHash=(patHash*BASE + pattern[i])%MOD;\n        txtHash=(txtHash*BASE + text[i])%MOD;\n    }\n    \n    for(int i=0;i<=n-m;i++){\n        if(txtHash == patHash && text.substr(i,m)==pattern)\n            return i;\n        if(i <n-m){\n            txtHash = (BASE*(txtHash - text[i]*h) + text[i+m])%MOD;\n            if(txtHash<0) txtHash += MOD;\n        }\n    }\n    return -1;\n}\n"
    },
    "word_search_trie": {
      "id": "word_search_trie",
      "title": "Word Search II",
      "difficulty": "hard",
      "description": "Find all words from a list present in a 2D grid using trie and backtracking.",
      "input_format": "2D character grid and list of words",
      "output_format": "List of found words",
      "constraints": [
        "m == grid.length",
        "n == grid[i].length"
      ],
      "example": {
        "input": "grid = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\"]",
        "output": "[\"oath\"]",
        "explanation": "\"oath\" is found in the grid"
      },
      "solution_approach": "Build trie of words. DFS backtracking on grid checking trie paths.",
      "related_concepts": [
        "trie",
        "backtracking"
      ],
      "cpp_solution": "\nstruct TrieNode {\n    TrieNode* children[26];\n    string word;\n    TrieNode() { fill(children, children+26, nullptr); word=\"\"; }\n};\n\nclass Solution {\n    vector<string> res;\npublic:\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n        TrieNode* root = buildTrie(words);\n        for(int i=0;i<board.size();i++)\n            for(int j=0;j<board[0].size();j++)\n                dfs(board,root,i,j);\n        return res;\n    }\n    \n    TrieNode* buildTrie(vector<string>& words){\n        TrieNode* root = new TrieNode();\n        for(string w:words){\n            TrieNode* p=root;\n            for(char c:w){\n                int i=c-'a';\n                if(!p->children[i]) p->children[i]=new TrieNode();\n                p=p->children[i];\n            }\n            p->word=w;\n        }\n        return root;\n    }\n    \n    void dfs(vector<vector<char>>& board, TrieNode* p, int i, int j){\n        char c=board[i][j];\n        if(c=='#' || !p->children[c-'a']) return;\n        p=p->children[c-'a'];\n        if(!p->word.empty()){\n            res.push_back(p->word);\n            p->word=\"\";\n        }\n        \n        board[i][j]='#';\n        if(i>0) dfs(board,p,i-1,j);\n        if(j>0) dfs(board,p,i,j-1);\n        if(i<board.size()-1) dfs(board,p,i+1,j);\n        if(j<board[0].size()-1) dfs(board,p,i,j+1);\n        board[i][j]=c;\n    }\n};\n"
    },
    "valid_anagram": {
      "id": "valid_anagram",
      "title": "Valid Anagram",
      "difficulty": "easy",
      "description": "Check if two strings are anagrams using counting sort.",
      "input_format": "Two strings s and t",
      "output_format": "Boolean indicating anagram status",
      "constraints": [
        "1 ≤ s.length, t.length ≤ 5*10^4"
      ],
      "example": {
        "input": "s = \"anagram\", t = \"nagaram\"",
        "output": "true",
        "explanation": "Both strings have same character counts"
      },
      "solution_approach": "Count character frequencies in both strings. Compare counts.",
      "related_concepts": [
        "frequency_count",
        "anagram_properties"
      ],
      "cpp_solution": "\nbool isAnagram(string s, string t) {\n    if(s.size()!=t.size()) return false;\n    vector<int> cnt(26);\n    for(char c:s) cnt[c-'a']++;\n    for(char c:t) if(--cnt[c-'a']<0) return false;\n    return true;\n}\n"
    },
    "minimum_window_substring": {
      "id": "minimum_window_substring",
      "title": "Minimum Window Substring",
      "difficulty": "hard",
      "description": "Find the smallest substring in s containing all characters in t using sliding window.",
      "input_format": "Strings s and t",
      "output_format": "Minimum window substring",
      "constraints": [
        "1 ≤ s.length, t.length ≤ 10^5"
      ],
      "example": {
        "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
        "output": "\"BANC\"",
        "explanation": "Shortest window containing A, B, C"
      },
      "solution_approach": "Use sliding window with two pointers and hash map to track required characters.",
      "related_concepts": [
        "sliding_window",
        "hash_map"
      ],
      "cpp_solution": "\nstring minWindow(string s, string t) {\n    vector<int> map(128);\n    for(char c:t) map[c]++;\n    int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0;\n    \n    while(end<s.size()){\n        if(map[s[end++]]-->0) counter--;\n        while(counter==0){\n            if(end-begin<d) d=end-(head=begin);\n            if(map[s[begin++]]++==0) counter++;\n        }\n    }\n    return d==INT_MAX ? \"\" : s.substr(head,d);\n}\n"
    },
    "regular_expression_matching": {
      "id": "regular_expression_matching",
      "title": "Regular Expression Matching",
      "difficulty": "hard",
      "description": "Implement regex matching supporting '.' and '*' using dynamic programming.",
      "input_format": "Strings s and p",
      "output_format": "Boolean indicating match status",
      "constraints": [
        "0 ≤ s.length ≤ 20",
        "0 ≤ p.length ≤ 30"
      ],
      "example": {
        "input": "s = \"aa\", p = \"a*\"",
        "output": "true",
        "explanation": "'*' matches zero or more preceding element"
      },
      "solution_approach": "DP[i][j] = true if s[0..i) matches p[0..j). Handle '*' by matching zero or more instances.",
      "related_concepts": [
        "dynamic_programming",
        "kleene_closure"
      ],
      "cpp_solution": "\nbool isMatch(string s, string p) {\n    int m=s.size(), n=p.size();\n    vector<vector<bool>> dp(m+1, vector<bool>(n+1, false));\n    dp[0][0]=true;\n    \n    for(int j=1;j<=n;j++)\n        if(p[j-1]=='*') dp[0][j] = dp[0][j-2];\n    \n    for(int i=1;i<=m;i++)\n        for(int j=1;j<=n;j++){\n            if(p[j-1]=='.' || p[j-1]==s[i-1])\n                dp[i][j] = dp[i-1][j-1];\n            else if(p[j-1]=='*'){\n                dp[i][j] = dp[i][j-2];\n                if(p[j-2]=='.' || p[j-2]==s[i-1])\n                    dp[i][j] = dp[i][j] || dp[i-1][j];\n            }\n        }\n    return dp[m][n];\n}\n"
  },
  "pow_x_n": {
      "id": "pow_x_n",
      "title": "Pow(x, n)",
      "difficulty": "medium",
      "description": "Implement pow(x, n) which calculates x raised to the power n using fast exponentiation algorithm.",
      "input_format": "Double x and integer n",
      "output_format": "Double result of x^n",
      "constraints": [
        "-100.0 < x < 100.0",
        "-2^31 ≤ n ≤ 2^31-1"
      ],
      "example": {
        "input": "x = 2.00000, n = 10",
        "output": "1024.00000",
        "explanation": "2^10 = 1024"
      },
      "solution_approach": "Binary exponentiation: if n is even, x^n = (x^(n/2))^2; if odd, x^n = x * x^(n-1). Handle negative exponents.",
      "related_concepts": [
        "fast_exponentiation",
        "binary_representation"
      ],
      "cpp_solution": "\ndouble myPow(double x, int n) {\n    if(n == 0) return 1;\n    long long N = abs((long long)n);\n    double result = 1;\n    double current_power = x;\n    \n    while(N > 0) {\n        if(N % 2 == 1) result *= current_power;\n        current_power *= current_power;\n        N /= 2;\n    }\n    return n < 0 ? 1/result : result;\n}\n"
    },
    "gcd_strings": {
      "id": "gcd_strings",
      "title": "Greatest Common Divisor of Strings",
      "difficulty": "easy",
      "description": "Find the largest string x such that both str1 and str2 can be formed by concatenating x multiple times.",
      "input_format": "Two strings str1 and str2",
      "output_format": "GCD string",
      "constraints": [
        "1 ≤ str1.length, str2.length ≤ 1000"
      ],
      "example": {
        "input": "str1 = \"ABCABC\", str2 = \"ABC\"",
        "output": "\"ABC\"",
        "explanation": "ABC is the largest string that divides both"
      },
      "solution_approach": "Check if str1 + str2 == str2 + str1. If yes, GCD exists and has length gcd(len1, len2).",
      "related_concepts": [
        "euclidean_algorithm",
        "string_properties"
      ],
      "cpp_solution": "\nstring gcdOfStrings(string str1, string str2) {\n    if(str1 + str2 != str2 + str1) return \"\";\n    int gcd_len = __gcd(str1.length(), str2.length());\n    return str1.substr(0, gcd_len);\n}\n"
    },
    "ugly_number_ii": {
      "id": "ugly_number_ii",
      "title": "Ugly Number II",
      "difficulty": "medium",
      "description": "Find the nth ugly number (positive integers whose prime factors are limited to 2, 3, and 5).",
      "input_format": "Integer n",
      "output_format": "nth ugly number",
      "constraints": [
        "1 ≤ n ≤ 1690"
      ],
      "example": {
        "input": "n = 10",
        "output": "12",
        "explanation": "1,2,3,4,5,6,8,9,10,12 are first 10 ugly numbers"
      },
      "solution_approach": "Use DP with three pointers for multiples of 2, 3, 5. Always pick minimum next ugly number.",
      "related_concepts": [
        "dynamic_programming",
        "multiple_pointers"
      ],
      "cpp_solution": "\nint nthUglyNumber(int n) {\n    vector<int> ugly(n);\n    ugly[0] = 1;\n    int p2=0, p3=0, p5=0;\n    \n    for(int i=1; i<n; i++) {\n        int next2 = ugly[p2] * 2;\n        int next3 = ugly[p3] * 3;\n        int next5 = ugly[p5] * 5;\n        \n        ugly[i] = min({next2, next3, next5});\n        \n        if(ugly[i] == next2) p2++;\n        if(ugly[i] == next3) p3++;\n        if(ugly[i] == next5) p5++;\n    }\n    return ugly[n-1];\n}\n"
    },
    "permutation_sequence": {
      "id": "permutation_sequence",
      "title": "Permutation Sequence",
      "difficulty": "hard",
      "description": "Find the kth permutation of numbers 1 to n using factoradic numbering system.",
      "input_format": "Integers n and k",
      "output_format": "kth permutation string",
      "constraints": [
        "1 ≤ n ≤ 9",
        "1 ≤ k ≤ n!"
      ],
      "example": {
        "input": "n = 3, k = 3",
        "output": "\"213\"",
        "explanation": "Permutations: 123, 132, 213, 231, 312, 321"
      },
      "solution_approach": "Use factorial base representation. For each position, calculate which number to pick based on remaining factorial.",
      "related_concepts": [
        "factoradic_system",
        "combinatorics"
      ],
      "cpp_solution": "\nstring getPermutation(int n, int k) {\n    vector<int> factorial(n), nums;\n    factorial[0] = 1;\n    for(int i=1; i<n; i++) factorial[i] = factorial[i-1] * i;\n    for(int i=1; i<=n; i++) nums.push_back(i);\n    \n    k--; // Convert to 0-indexed\n    string result;\n    for(int i=n-1; i>=0; i--) {\n        int idx = k / factorial[i];\n        result += to_string(nums[idx]);\n        nums.erase(nums.begin() + idx);\n        k %= factorial[i];\n    }\n    return result;\n}\n"
    },
    "basic_calculator": {
      "id": "basic_calculator",
      "title": "Basic Calculator",
      "difficulty": "hard",
      "description": "Implement a basic calculator to evaluate arithmetic expressions with +, -, *, / and parentheses.",
      "input_format": "String s representing arithmetic expression",
      "output_format": "Integer result",
      "constraints": [
        "1 ≤ s.length ≤ 3*10^5",
        "Valid expression with +, -, *, /, (, ), digits, spaces"
      ],
      "example": {
        "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
        "output": "23",
        "explanation": "Expression evaluates to 23"
      },
      "solution_approach": "Use two stacks: one for operands, one for operators. Handle precedence and parentheses.",
      "related_concepts": [
        "stack_evaluation",
        "operator_precedence"
      ],
      "cpp_solution": "\nint calculate(string s) {\n    stack<int> nums;\n    stack<char> ops;\n    \n    auto apply = [&]() {\n        int b = nums.top(); nums.pop();\n        int a = nums.top(); nums.pop();\n        char op = ops.top(); ops.pop();\n        if(op == '+') nums.push(a + b);\n        else if(op == '-') nums.push(a - b);\n        else if(op == '*') nums.push(a * b);\n        else nums.push(a / b);\n    };\n    \n    auto precedence = [](char op) {\n        return op == '*' || op == '/' ? 2 : 1;\n    };\n    \n    for(int i=0; i<s.size(); i++) {\n        if(s[i] == ' ') continue;\n        if(isdigit(s[i])) {\n            int num = 0;\n            while(i < s.size() && isdigit(s[i]))\n                num = num * 10 + (s[i++] - '0');\n            nums.push(num);\n            i--;\n        } else if(s[i] == '(') {\n            ops.push(s[i]);\n        } else if(s[i] == ')') {\n            while(ops.top() != '(') apply();\n            ops.pop();\n        } else {\n            while(!ops.empty() && ops.top() != '(' && \n                  precedence(ops.top()) >= precedence(s[i])) apply();\n            ops.push(s[i]);\n        }\n    }\n    while(!ops.empty()) apply();\n    return nums.top();\n}\n"
    },
    "count_primes": {
      "id": "count_primes",
      "title": "Count Primes",
      "difficulty": "easy",
      "description": "Count the number of prime numbers less than n using Sieve of Eratosthenes.",
      "input_format": "Integer n",
      "output_format": "Count of primes less than n",
      "constraints": [
        "0 ≤ n ≤ 5*10^6"
      ],
      "example": {
        "input": "n = 10",
        "output": "4",
        "explanation": "Primes less than 10: 2, 3, 5, 7"
      },
      "solution_approach": "Sieve of Eratosthenes: mark multiples of each prime starting from 2.",
      "related_concepts": [
        "sieve_algorithm",
        "prime_numbers"
      ],
      "cpp_solution": "\nint countPrimes(int n) {\n    if(n <= 2) return 0;\n    vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    for(int i=2; i*i<n; i++) {\n        if(is_prime[i]) {\n            for(int j=i*i; j<n; j+=i)\n                is_prime[j] = false;\n        }\n    }\n    return count(is_prime.begin(), is_prime.end(), true);\n}\n"
    },
    "fraction_recurring_decimal": {
      "id": "fraction_recurring_decimal",
      "title": "Fraction to Recurring Decimal",
      "difficulty": "medium",
      "description": "Convert fraction to decimal string with recurring pattern detection using hash map.",
      "input_format": "Integers numerator and denominator",
      "output_format": "Decimal representation string",
      "constraints": [
        "-2^31 ≤ numerator, denominator ≤ 2^31-1",
        "denominator ≠ 0"
      ],
      "example": {
        "input": "numerator = 1, denominator = 3",
        "output": "\"0.(3)\"",
        "explanation": "1/3 = 0.333... with recurring 3"
      },
      "solution_approach": "Track remainders in hash map. When remainder repeats, we found the cycle.",
      "related_concepts": [
        "long_division",
        "cycle_detection"
      ],
      "cpp_solution": "\nstring fractionToDecimal(int numerator, int denominator) {\n    if(numerator == 0) return \"0\";\n    string result;\n    if((numerator < 0) ^ (denominator < 0)) result += \"-\";\n    \n    long long num = abs((long long)numerator);\n    long long den = abs((long long)denominator);\n    \n    result += to_string(num / den);\n    num %= den;\n    if(num == 0) return result;\n    \n    result += \".\";\n    unordered_map<long long, int> remainder_map;\n    \n    while(num != 0) {\n        if(remainder_map.count(num)) {\n            result.insert(remainder_map[num], \"(\");\n            result += \")\";\n            break;\n        }\n        remainder_map[num] = result.length();\n        num *= 10;\n        result += to_string(num / den);\n        num %= den;\n    }\n    return result;\n}\n"
    },
    "perfect_number": {
      "id": "perfect_number",
      "title": "Perfect Number",
      "difficulty": "easy",
      "description": "Check if a positive integer is a perfect number (sum of proper divisors equals the number).",
      "input_format": "Integer num",
      "output_format": "Boolean indicating perfect number",
      "constraints": [
        "1 ≤ num ≤ 10^8"
      ],
      "example": {
        "input": "num = 28",
        "output": "true",
        "explanation": "28 = 1 + 2 + 4 + 7 + 14"
      },
      "solution_approach": "Find all divisors up to sqrt(num). Sum proper divisors and check equality.",
      "related_concepts": [
        "number_theory",
        "divisor_enumeration"
      ],
      "cpp_solution": "\nbool checkPerfectNumber(int num) {\n    if(num <= 1) return false;\n    int sum = 1;\n    for(int i=2; i*i<=num; i++) {\n        if(num % i == 0) {\n            sum += i;\n            if(i != num/i) sum += num/i;\n        }\n    }\n    return sum == num;\n}\n"
    },
    "integer_break": {
      "id": "integer_break",
      "title": "Integer Break",
      "difficulty": "medium",
      "description": "Break positive integer n into sum of at least two integers to maximize their product.",
      "input_format": "Integer n",
      "output_format": "Maximum product",
      "constraints": [
        "2 ≤ n ≤ 58"
      ],
      "example": {
        "input": "n = 10",
        "output": "36",
        "explanation": "10 = 3 + 3 + 4, product = 3 × 3 × 4 = 36"
      },
      "solution_approach": "Mathematical insight: prefer 3s, use 2s when remainder is 1. Avoid 1s in factorization.",
      "related_concepts": [
        "number_theory",
        "optimization"
      ],
      "cpp_solution": "\nint integerBreak(int n) {\n    if(n == 2) return 1;\n    if(n == 3) return 2;\n    \n    int product = 1;\n    while(n > 4) {\n        product *= 3;\n        n -= 3;\n    }\n    return product * n;\n}\n"
    },
    "robot_bounded_circle": {
      "id": "robot_bounded_circle",
      "title": "Robot Bounded In Circle",
      "difficulty": "medium",
      "description": "Determine if robot returns to origin after executing instructions using modular arithmetic.",
      "input_format": "String instructions with 'G' (go), 'L' (left), 'R' (right)",
      "output_format": "Boolean indicating bounded movement",
      "constraints": [
        "1 ≤ instructions.length ≤ 100"
      ],
      "example": {
        "input": "instructions = \"GGLLGG\"",
        "output": "true",
        "explanation": "Robot returns to origin after cycles"
      },
      "solution_approach": "After one cycle: if at origin OR not facing north, robot is bounded in circle.",
      "related_concepts": [
        "modular_arithmetic",
        "periodic_motion"
      ],
      "cpp_solution": "\nbool isRobotBounded(string instructions) {\n    int x=0, y=0, dir=0; // 0:North, 1:East, 2:South, 3:West\n    vector<vector<int>> directions = {{0,1},{1,0},{0,-1},{-1,0}};\n    \n    for(char c : instructions) {\n        if(c == 'G') {\n            x += directions[dir][0];\n            y += directions[dir][1];\n        } else if(c == 'L') {\n            dir = (dir + 3) % 4;\n        } else {\n            dir = (dir + 1) % 4;\n        }\n    }\n    return (x==0 && y==0) || dir != 0;\n}\n"
    },  
  "lru_cache": {
        "id": "lru_cache",
        "title": "LRU Cache",
        "difficulty": "medium",
        "description": "Design a data structure that follows Least Recently Used (LRU) cache constraints using hash map and doubly linked list.",
        "input_format": "Operations: get(key), put(key, value)",
        "output_format": "Integer for get, void for put",
        "constraints": [
          "1 ≤ capacity ≤ 3000",
          "0 ≤ key ≤ 10^4",
          "0 ≤ value ≤ 10^5"
        ],
        "example": {
          "input": "LRUCache(2); put(1,1); put(2,2); get(1); put(3,3); get(2); put(4,4); get(1); get(3); get(4)",
          "output": "[null,null,null,1,null,-1,null,-1,3,4]",
          "explanation": "Cache evicts least recently used items when capacity exceeded"
        },
        "solution_approach": "Hash map for O(1) lookup + doubly linked list for O(1) insertion/deletion. Most recent at head, least recent at tail.",
        "related_concepts": [
          "hash_map",
          "doubly_linked_list"
        ],
        "cpp_solution": "\nstruct Node {\n    int key, val;\n    Node* prev, *next;\n    Node(int k=0, int v=0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n    unordered_map<int, Node*> cache;\n    Node* head, *tail;\n    int capacity;\n    \n    void removeNode(Node* node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n    \n    void addToHead(Node* node) {\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n        node->prev = head;\n    }\n    \npublic:\n    LRUCache(int cap) : capacity(cap) {\n        head = new Node();\n        tail = new Node();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if(cache.count(key)) {\n            Node* node = cache[key];\n            removeNode(node);\n            addToHead(node);\n            return node->val;\n        }\n        return -1;\n    }\n    \n    void put(int key, int value) {\n        if(cache.count(key)) {\n            Node* node = cache[key];\n            node->val = value;\n            removeNode(node);\n            addToHead(node);\n        } else {\n            if(cache.size() == capacity) {\n                Node* last = tail->prev;\n                cache.erase(last->key);\n                removeNode(last);\n                delete last;\n            }\n            Node* newNode = new Node(key, value);\n            cache[key] = newNode;\n            addToHead(newNode);\n        }\n    }\n};\n"
      },
      "group_anagrams": {
        "id": "group_anagrams",
        "title": "Group Anagrams",
        "difficulty": "medium",
        "description": "Group strings that are anagrams of each other using hash map with sorted string keys.",
        "input_format": "Array of strings strs",
        "output_format": "List of grouped anagrams",
        "constraints": [
          "1 ≤ strs.length ≤ 10^4",
          "0 ≤ strs[i].length ≤ 100"
        ],
        "example": {
          "input": "[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "explanation": "Anagrams grouped by sorted character pattern"
        },
        "solution_approach": "Sort each string to create hash key. Group strings with same sorted key.",
        "related_concepts": [
          "hash_map",
          "string_sorting"
        ],
        "cpp_solution": "\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\n    unordered_map<string, vector<string>> groups;\n    for(string& str : strs) {\n        string key = str;\n        sort(key.begin(), key.end());\n        groups[key].push_back(str);\n    }\n    vector<vector<string>> result;\n    for(auto& [key, group] : groups)\n        result.push_back(group);\n    return result;\n}\n"
      },
      "longest_substring_no_repeat": {
        "id": "longest_substring_no_repeat",
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "medium",
        "description": "Find the length of the longest substring without repeating characters using sliding window and hash set.",
        "input_format": "String s",
        "output_format": "Integer length",
        "constraints": [
          "0 ≤ s.length ≤ 5*10^4"
        ],
        "example": {
          "input": "\"abcabcbb\"",
          "output": "3",
          "explanation": "Substring \"abc\" has length 3"
        },
        "solution_approach": "Sliding window with hash map to track character positions. Expand right, shrink left when duplicate found.",
        "related_concepts": [
          "sliding_window",
          "hash_map"
        ],
        "cpp_solution": "\nint lengthOfLongestSubstring(string s) {\n    unordered_map<char, int> charIndex;\n    int maxLen = 0, left = 0;\n    for(int right = 0; right < s.length(); right++) {\n        if(charIndex.count(s[right]) && charIndex[s[right]] >= left)\n            left = charIndex[s[right]] + 1;\n        charIndex[s[right]] = right;\n        maxLen = max(maxLen, right - left + 1);\n    }\n    return maxLen;\n}\n"
      },
      "insert_delete_getrandom": {
        "id": "insert_delete_getrandom",
        "title": "Insert Delete GetRandom O(1)",
        "difficulty": "medium",
        "description": "Design a data structure supporting insert, delete, and getRandom operations in O(1) time using hash map and dynamic array.",
        "input_format": "Operations: insert(val), remove(val), getRandom()",
        "output_format": "Boolean for insert/remove, integer for getRandom",
        "constraints": [
          "-2^31 ≤ val ≤ 2^31-1",
          "At most 2*10^5 calls total"
        ],
        "example": {
          "input": "insert(1); remove(2); insert(2); getRandom(); remove(1); insert(2); getRandom()",
          "output": "[true,false,true,2,true,false,2]",
          "explanation": "Operations maintain O(1) complexity"
        },
        "solution_approach": "Array for O(1) random access, hash map for O(1) lookup. Swap with last element for O(1) deletion.",
        "related_concepts": [
          "hash_map",
          "dynamic_array"
        ],
        "cpp_solution": "\nclass RandomizedSet {\n    vector<int> vals;\n    unordered_map<int, int> valToIndex;\npublic:\n    bool insert(int val) {\n        if(valToIndex.count(val)) return false;\n        vals.push_back(val);\n        valToIndex[val] = vals.size()-1;\n        return true;\n    }\n    \n    bool remove(int val) {\n        if(!valToIndex.count(val)) return false;\n        int idx = valToIndex[val];\n        int lastVal = vals.back();\n        vals[idx] = lastVal;\n        valToIndex[lastVal] = idx;\n        vals.pop_back();\n        valToIndex.erase(val);\n        return true;\n    }\n    \n    int getRandom() {\n        return vals[rand() % vals.size()];\n    }\n};\n"
      },
      "subarray_sum_k": {
        "id": "subarray_sum_k",
        "title": "Subarray Sum Equals K",
        "difficulty": "medium",
        "description": "Find the number of continuous subarrays whose sum equals k using prefix sum and hash map.",
        "input_format": "Array nums and integer k",
        "output_format": "Integer count",
        "constraints": [
          "1 ≤ nums.length ≤ 2*10^4",
          "-1000 ≤ nums[i] ≤ 1000"
        ],
        "example": {
          "input": "nums = [1,1,1], k = 2",
          "output": "2",
          "explanation": "Subarrays [1,1] at indices (0,1) and (1,2)"
        },
        "solution_approach": "Track prefix sums in hash map. For each position, check if (current_sum - k) exists.",
        "related_concepts": [
          "prefix_sum",
          "hash_map"
        ],
        "cpp_solution": "\nint subarraySum(vector<int>& nums, int k) {\n    int count = 0, prefixSum = 0;\n    unordered_map<int, int> sumCount{{0, 1}};\n    for(int num : nums) {\n        prefixSum += num;\n        if(sumCount.count(prefixSum - k))\n            count += sumCount[prefixSum - k];\n        sumCount[prefixSum]++;\n    }\n    return count;\n}\n"
      },
      "jewels_stones": {
        "id": "jewels_stones",
        "title": "Jewels and Stones",
        "difficulty": "easy",
        "description": "Count how many stones are jewels using hash set for fast lookup.",
        "input_format": "String jewels and string stones",
        "output_format": "Integer count",
        "constraints": [
          "1 ≤ jewels.length, stones.length ≤ 50"
        ],
        "example": {
          "input": "jewels = \"aA\", stones = \"aAAbbbb\"",
          "output": "3",
          "explanation": "Three stones 'a', 'A', 'A' are jewels"
        },
        "solution_approach": "Store jewels in hash set for O(1) lookup. Count stones that exist in jewels set.",
        "related_concepts": [
          "hash_set",
          "counting"
        ],
        "cpp_solution": "\nint numJewelsInStones(string jewels, string stones) {\n    unordered_set<char> jewelSet(jewels.begin(), jewels.end());\n    int count = 0;\n    for(char stone : stones)\n        if(jewelSet.count(stone)) count++;\n    return count;\n}\n"
      },
      "top_k_frequent": {
        "id": "top_k_frequent",
        "title": "Top K Frequent Elements",
        "difficulty": "medium",
        "description": "Find the k most frequent elements using hash map for counting and heap for selection.",
        "input_format": "Array nums and integer k",
        "output_format": "Array of k most frequent elements",
        "constraints": [
          "1 ≤ nums.length ≤ 10^5",
          "1 ≤ k ≤ number of unique elements"
        ],
        "example": {
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "output": "[1,2]",
          "explanation": "Elements 1 and 2 are most frequent"
        },
        "solution_approach": "Count frequencies with hash map. Use min-heap of size k to track top frequencies.",
        "related_concepts": [
          "hash_map",
          "min_heap"
        ],
        "cpp_solution": "\nvector<int> topKFrequent(vector<int>& nums, int k) {\n    unordered_map<int, int> count;\n    for(int num : nums) count[num]++;\n    \n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\n    for(auto& [num, freq] : count) {\n        pq.push({freq, num});\n        if(pq.size() > k) pq.pop();\n    }\n    \n    vector<int> result;\n    while(!pq.empty()) {\n        result.push_back(pq.top().second);\n        pq.pop();\n    }\n    return result;\n}\n"
      },
      "four_sum_ii": {
        "id": "four_sum_ii",
        "title": "4Sum II",
        "difficulty": "medium",
        "description": "Count 4-tuples from four arrays that sum to zero using hash map for pair counting.",
        "input_format": "Four arrays nums1, nums2, nums3, nums4",
        "output_format": "Integer count of valid tuples",
        "constraints": [
          "n == nums1.length == nums2.length == nums3.length == nums4.length",
          "1 ≤ n ≤ 200"
        ],
        "example": {
          "input": "nums1=[1,2], nums2=[-2,-1], nums3=[-1,2], nums4=[0,2]",
          "output": "2",
          "explanation": "Two valid combinations: (1,-1,-1,1) and (2,-2,0,0)"
        },
        "solution_approach": "Count all sums from first two arrays. For each sum from last two arrays, check if complement exists.",
        "related_concepts": [
          "hash_map",
          "complement_counting"
        ],
        "cpp_solution": "\nint fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n    unordered_map<int, int> sumCount;\n    for(int a : nums1)\n        for(int b : nums2)\n            sumCount[a + b]++;\n    \n    int count = 0;\n    for(int c : nums3)\n        for(int d : nums4)\n            if(sumCount.count(-(c + d)))\n                count += sumCount[-(c + d)];\n    return count;\n}\n"
      },
      "logger_rate_limiter": {
        "id": "logger_rate_limiter",
        "title": "Logger Rate Limiter",
        "difficulty": "easy",
        "description": "Design a logger that rate limits messages to at most once every 10 seconds using timestamp hashing.",
        "input_format": "Operations: shouldPrintMessage(timestamp, message)",
        "output_format": "Boolean indicating if message should be printed",
        "constraints": [
          "0 ≤ timestamp ≤ 10^9",
          "Timestamps are non-decreasing"
        ],
        "example": {
          "input": "shouldPrintMessage(1,\"foo\"); shouldPrintMessage(2,\"bar\"); shouldPrintMessage(3,\"foo\")",
          "output": "[true,true,false]",
          "explanation": "Second 'foo' is within 10 seconds of first"
        },
        "solution_approach": "Hash map stores message → last timestamp. Check if current timestamp is ≥ last + 10.",
        "related_concepts": [
          "hash_map",
          "timestamp_tracking"
        ],
        "cpp_solution": "\nclass Logger {\n    unordered_map<string, int> lastTime;\npublic:\n    bool shouldPrintMessage(int timestamp, string message) {\n        if(lastTime.count(message) && timestamp - lastTime[message] < 10)\n            return false;\n        lastTime[message] = timestamp;\n        return true;\n    }\n};\n"
      },
      "design_hashmap": {
        "id": "design_hashmap",
        "title": "Design HashMap",
        "difficulty": "easy",
        "description": "Design a hash map without built-in libraries using array and chaining/open addressing for collision resolution.",
        "input_format": "Operations: put(key,value), get(key), remove(key)",
        "output_format": "Void for put/remove, integer for get",
        "constraints": [
          "0 ≤ key, value ≤ 10^6",
          "At most 10^4 calls"
        ],
        "example": {
          "input": "put(1,1); put(2,2); get(1); get(3); put(2,1); get(2); remove(2); get(2)",
          "output": "[null,null,1,-1,null,1,null,-1]",
          "explanation": "Basic hash map operations with collision handling"
        },
        "solution_approach": "Array of buckets with chaining using linked lists. Hash function maps keys to bucket indices.",
        "related_concepts": [
          "hash_function",
          "collision_resolution"
        ],
        "cpp_solution": "\nclass MyHashMap {\n    struct Node {\n        int key, val;\n        Node* next;\n        Node(int k, int v) : key(k), val(v), next(nullptr) {}\n    };\n    \n    static const int SIZE = 10007;\n    Node* buckets[SIZE];\n    \n    int hash(int key) { return key % SIZE; }\n    \npublic:\n    MyHashMap() { fill(buckets, buckets + SIZE, nullptr); }\n    \n    void put(int key, int value) {\n        int idx = hash(key);\n        if(!buckets[idx]) {\n            buckets[idx] = new Node(key, value);\n            return;\n        }\n        Node* curr = buckets[idx];\n        while(curr) {\n            if(curr->key == key) {\n                curr->val = value;\n                return;\n            }\n            if(!curr->next) break;\n            curr = curr->next;\n        }\n        curr->next = new Node(key, value);\n    }\n    \n    int get(int key) {\n        int idx = hash(key);\n        Node* curr = buckets[idx];\n        while(curr) {\n            if(curr->key == key) return curr->val;\n            curr = curr->next;\n        }\n        return -1;\n    }\n    \n    void remove(int key) {\n        int idx = hash(key);\n        if(!buckets[idx]) return;\n        if(buckets[idx]->key == key) {\n            buckets[idx] = buckets[idx]->next;\n            return;\n        }\n        Node* curr = buckets[idx];\n        while(curr->next && curr->next->key != key)\n            curr = curr->next;\n        if(curr->next) curr->next = curr->next->next;\n    }\n};\n"
  },
  "validate_bst": {
      "id": "validate_bst",
      "title": "Validate Binary Search Tree",
      "difficulty": "medium",
      "description": "Determine if a binary tree is a valid BST using inorder traversal property check.",
      "input_format": "Root of binary tree",
      "output_format": "Boolean indicating validity",
      "constraints": [
        "Number of nodes: [1, 10^4]",
        "-2^31 ≤ Node.val ≤ 2^31-1"
      ],
      "example": {
        "input": "root = [5,1,4,null,null,3,6]",
        "output": "false",
        "explanation": "Node 3 is not between 1 and 5"
      },
      "solution_approach": "Inorder traversal should yield sorted sequence. Track previous value during traversal.",
      "related_concepts": [
        "inorder_traversal",
        "bst_properties"
      ],
      "cpp_solution": "\nstruct TreeNode {\n    int val;\n    TreeNode *left, *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\n    TreeNode* prev = nullptr;\npublic:\n    bool isValidBST(TreeNode* root) {\n        if(!root) return true;\n        if(!isValidBST(root->left)) return false;\n        if(prev && prev->val >= root->val) return false;\n        prev = root;\n        return isValidBST(root->right);\n    }\n};\n"
    },
    "serialize_deserialize_bst": {
      "id": "serialize_deserialize_bst",
      "title": "Serialize and Deserialize BST",
      "difficulty": "hard",
      "description": "Design algorithm to serialize BST to string and deserialize back using preorder traversal.",
      "input_format": "BST root for serialize, string for deserialize",
      "output_format": "String for serialize, TreeNode for deserialize",
      "constraints": [
        "Number of nodes: [0, 10^4]",
        "0 ≤ Node.val ≤ 10^4"
      ],
      "example": {
        "input": "root = [2,1,3]",
        "output": "\"2,1,3\"",
        "explanation": "Preorder traversal encoding"
      },
      "solution_approach": "Serialize using preorder traversal. Deserialize by reconstructing BST from preorder sequence.",
      "related_concepts": [
        "preorder_traversal",
        "bst_reconstruction"
      ],
      "cpp_solution": "\nclass Codec {\npublic:\n    string serialize(TreeNode* root) {\n        string data;\n        preorder(root, data);\n        return data;\n    }\n    \n    void preorder(TreeNode* root, string& data) {\n        if(!root) return;\n        data += to_string(root->val) + \",\";\n        preorder(root->left, data);\n        preorder(root->right, data);\n    }\n    \n    TreeNode* deserialize(string data) {\n        if(data.empty()) return nullptr;\n        stringstream ss(data);\n        string val;\n        vector<int> vals;\n        while(getline(ss, val, ',') && !val.empty())\n            vals.push_back(stoi(val));\n        int idx = 0;\n        return buildBST(vals, idx, INT_MIN, INT_MAX);\n    }\n    \n    TreeNode* buildBST(vector<int>& vals, int& idx, int minVal, int maxVal) {\n        if(idx >= vals.size() || vals[idx] < minVal || vals[idx] > maxVal)\n            return nullptr;\n        int val = vals[idx++];\n        TreeNode* root = new TreeNode(val);\n        root->left = buildBST(vals, idx, minVal, val);\n        root->right = buildBST(vals, idx, val, maxVal);\n        return root;\n    }\n};\n"
    },
    "lowest_common_ancestor": {
      "id": "lowest_common_ancestor",
      "title": "Lowest Common Ancestor of BST",
      "difficulty": "medium",
      "description": "Find lowest common ancestor of two nodes in BST using BST property optimization.",
      "input_format": "BST root and two target nodes p, q",
      "output_format": "LCA TreeNode",
      "constraints": [
        "Number of nodes: [2, 10^5]",
        "-10^9 ≤ Node.val ≤ 10^9"
      ],
      "example": {
        "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
        "output": "6",
        "explanation": "LCA of 2 and 8 is 6"
      },
      "solution_approach": "Use BST property: if both nodes are smaller, go left; if both larger, go right; otherwise current is LCA.",
      "related_concepts": [
        "bst_properties",
        "tree_traversal"
      ],
      "cpp_solution": "\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    while(root) {\n        if(p->val < root->val && q->val < root->val)\n            root = root->left;\n        else if(p->val > root->val && q->val > root->val)\n            root = root->right;\n        else\n            return root;\n    }\n    return nullptr;\n}\n"
    },
    "avl_tree_implementation": {
      "id": "avl_tree_implementation",
      "title": "AVL Tree Implementation",
      "difficulty": "hard",
      "description": "Implement self-balancing AVL tree with insertion and rotation cases.",
      "input_format": "Values to insert into AVL tree",
      "output_format": "Balanced AVL tree",
      "constraints": [
        "Number of operations ≤ 10^4",
        "-10^6 ≤ values ≤ 10^6"
      ],
      "example": {
        "input": "Insert: 10, 20, 30",
        "output": "Balanced tree with root 20",
        "explanation": "Right-heavy tree triggers left rotation"
      },
      "solution_approach": "Track height and balance factor. Perform rotations when |balance| > 1.",
      "related_concepts": [
        "tree_rotation",
        "balance_factor"
      ],
      "cpp_solution": "\nstruct AVLNode {\n    int val, height;\n    AVLNode *left, *right;\n    AVLNode(int x) : val(x), height(1), left(nullptr), right(nullptr) {}\n};\n\nclass AVLTree {\n    int getHeight(AVLNode* node) {\n        return node ? node->height : 0;\n    }\n    \n    int getBalance(AVLNode* node) {\n        return node ? getHeight(node->left) - getHeight(node->right) : 0;\n    }\n    \n    void updateHeight(AVLNode* node) {\n        if(node) node->height = 1 + max(getHeight(node->left), getHeight(node->right));\n    }\n    \n    AVLNode* rotateRight(AVLNode* y) {\n        AVLNode* x = y->left;\n        y->left = x->right;\n        x->right = y;\n        updateHeight(y);\n        updateHeight(x);\n        return x;\n    }\n    \n    AVLNode* rotateLeft(AVLNode* x) {\n        AVLNode* y = x->right;\n        x->right = y->left;\n        y->left = x;\n        updateHeight(x);\n        updateHeight(y);\n        return y;\n    }\n    \npublic:\n    AVLNode* insert(AVLNode* root, int val) {\n        if(!root) return new AVLNode(val);\n        if(val < root->val) root->left = insert(root->left, val);\n        else if(val > root->val) root->right = insert(root->right, val);\n        else return root;\n        \n        updateHeight(root);\n        int balance = getBalance(root);\n        \n        // Left Left Case\n        if(balance > 1 && val < root->left->val)\n            return rotateRight(root);\n        // Right Right Case\n        if(balance < -1 && val > root->right->val)\n            return rotateLeft(root);\n        // Left Right Case\n        if(balance > 1 && val > root->left->val) {\n            root->left = rotateLeft(root->left);\n            return rotateRight(root);\n        }\n        // Right Left Case\n        if(balance < -1 && val < root->right->val) {\n            root->right = rotateRight(root->right);\n            return rotateLeft(root);\n        }\n        return root;\n    }\n};\n"
    },
    "red_black_tree_insertion": {
      "id": "red_black_tree_insertion",
      "title": "Red-Black Tree Insertion",
      "difficulty": "hard",
      "description": "Implement Red-Black tree insertion with color flipping and rotation for balance maintenance.",
      "input_format": "Values to insert into RB tree",
      "output_format": "Balanced RB tree",
      "constraints": [
        "Number of operations ≤ 10^4",
        "-10^6 ≤ values ≤ 10^6"
      ],
      "example": {
        "input": "Insert: 10, 20, 30",
        "output": "Balanced RB tree with proper coloring",
        "explanation": "Maintains RB properties through rotations"
      },
      "solution_approach": "Maintain RB properties: root black, no adjacent red nodes, equal black height. Fix violations with rotations and recoloring.",
      "related_concepts": [
        "tree_coloring",
        "rb_properties"
      ],
      "cpp_solution": "\nenum Color { RED, BLACK };\n\nstruct RBNode {\n    int val;\n    Color color;\n    RBNode *left, *right, *parent;\n    RBNode(int x) : val(x), color(RED), left(nullptr), right(nullptr), parent(nullptr) {}\n};\n\nclass RedBlackTree {\n    RBNode* root;\n    \n    void rotateLeft(RBNode* x) {\n        RBNode* y = x->right;\n        x->right = y->left;\n        if(y->left) y->left->parent = x;\n        y->parent = x->parent;\n        if(!x->parent) root = y;\n        else if(x == x->parent->left) x->parent->left = y;\n        else x->parent->right = y;\n        y->left = x;\n        x->parent = y;\n    }\n    \n    void rotateRight(RBNode* y) {\n        RBNode* x = y->left;\n        y->left = x->right;\n        if(x->right) x->right->parent = y;\n        x->parent = y->parent;\n        if(!y->parent) root = x;\n        else if(y == y->parent->left) y->parent->left = x;\n        else y->parent->right = x;\n        x->right = y;\n        y->parent = x;\n    }\n    \n    void fixInsert(RBNode* node) {\n        while(node != root && node->parent->color == RED) {\n            if(node->parent == node->parent->parent->left) {\n                RBNode* uncle = node->parent->parent->right;\n                if(uncle && uncle->color == RED) {\n                    node->parent->color = BLACK;\n                    uncle->color = BLACK;\n                    node->parent->parent->color = RED;\n                    node = node->parent->parent;\n                } else {\n                    if(node == node->parent->right) {\n                        node = node->parent;\n                        rotateLeft(node);\n                    }\n                    node->parent->color = BLACK;\n                    node->parent->parent->color = RED;\n                    rotateRight(node->parent->parent);\n                }\n            } else {\n                // Mirror case\n                RBNode* uncle = node->parent->parent->left;\n                if(uncle && uncle->color == RED) {\n                    node->parent->color = BLACK;\n                    uncle->color = BLACK;\n                    node->parent->parent->color = RED;\n                    node = node->parent->parent;\n                } else {\n                    if(node == node->parent->left) {\n                        node = node->parent;\n                        rotateRight(node);\n                    }\n                    node->parent->color = BLACK;\n                    node->parent->parent->color = RED;\n                    rotateLeft(node->parent->parent);\n                }\n            }\n        }\n        root->color = BLACK;\n    }\n    \npublic:\n    void insert(int val) {\n        RBNode* node = new RBNode(val);\n        RBNode* parent = nullptr;\n        RBNode* current = root;\n        \n        while(current) {\n            parent = current;\n            if(node->val < current->val) current = current->left;\n            else current = current->right;\n        }\n        \n        node->parent = parent;\n        if(!parent) root = node;\n        else if(node->val < parent->val) parent->left = node;\n        else parent->right = node;\n        \n        fixInsert(node);\n    }\n};\n"
    },
    "kth_smallest_bst": {
      "id": "kth_smallest_bst",
      "title": "Kth Smallest Element in BST",
      "difficulty": "medium",
      "description": "Find kth smallest element in BST using inorder traversal property.",
      "input_format": "BST root and integer k",
      "output_format": "Integer kth smallest value",
      "constraints": [
        "Number of nodes: [1, 10^4]",
        "1 ≤ k ≤ number of nodes"
      ],
      "example": {
        "input": "root = [3,1,4,null,2], k = 1",
        "output": "1",
        "explanation": "1st smallest element is 1"
      },
      "solution_approach": "Inorder traversal visits nodes in sorted order. Stop at kth node.",
      "related_concepts": [
        "inorder_traversal",
        "bst_properties"
      ],
      "cpp_solution": "\nclass Solution {\n    int count = 0, result = 0;\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        inorder(root, k);\n        return result;\n    }\n    \n    void inorder(TreeNode* root, int k) {\n        if(!root || count >= k) return;\n        inorder(root->left, k);\n        if(++count == k) {\n            result = root->val;\n            return;\n        }\n        inorder(root->right, k);\n    }\n};\n"
    },
    "binary_tree_max_path_sum": {
      "id": "binary_tree_max_path_sum",
      "title": "Binary Tree Maximum Path Sum",
      "difficulty": "hard",
      "description": "Find maximum sum path in binary tree using post-order traversal.",
      "input_format": "Binary tree root",
      "output_format": "Integer maximum path sum",
      "constraints": [
        "Number of nodes: [1, 3*10^4]",
        "-1000 ≤ Node.val ≤ 1000"
      ],
      "example": {
        "input": "root = [1,2,3]",
        "output": "6",
        "explanation": "Path 2->1->3 has sum 6"
      },
      "solution_approach": "Post-order traversal computing max gain from each subtree. Update global max considering path through current node.",
      "related_concepts": [
        "post_order_traversal",
        "path_optimization"
      ],
      "cpp_solution": "\nclass Solution {\n    int maxSum = INT_MIN;\npublic:\n    int maxPathSum(TreeNode* root) {\n        maxGain(root);\n        return maxSum;\n    }\n    \n    int maxGain(TreeNode* node) {\n        if(!node) return 0;\n        int leftGain = max(maxGain(node->left), 0);\n        int rightGain = max(maxGain(node->right), 0);\n        int priceNewPath = node->val + leftGain + rightGain;\n        maxSum = max(maxSum, priceNewPath);\n        return node->val + max(leftGain, rightGain);\n    }\n};\n"
    },
    "vertical_order_traversal": {
      "id": "vertical_order_traversal",
      "title": "Vertical Order Traversal",
      "difficulty": "hard",
      "description": "Print binary tree nodes in vertical order using BFS with coordinate tracking.",
      "input_format": "Binary tree root",
      "output_format": "2D array of nodes by vertical position",
      "constraints": [
        "Number of nodes: [1, 1000]",
        "-1000 ≤ Node.val ≤ 1000"
      ],
      "example": {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[9],[3,15],[20],[7]]",
        "explanation": "Nodes grouped by column position"
      },
      "solution_approach": "BFS tracking (row, col) coordinates. Group nodes by column, sort by row then value.",
      "related_concepts": [
        "bfs",
        "coordinate_mapping"
      ],
      "cpp_solution": "\nvector<vector<int>> verticalTraversal(TreeNode* root) {\n    map<int, map<int, multiset<int>>> nodes;\n    queue<tuple<TreeNode*, int, int>> q;\n    q.push({root, 0, 0});\n    \n    while(!q.empty()) {\n        auto [node, row, col] = q.front();\n        q.pop();\n        nodes[col][row].insert(node->val);\n        if(node->left) q.push({node->left, row+1, col-1});\n        if(node->right) q.push({node->right, row+1, col+1});\n    }\n    \n    vector<vector<int>> result;\n    for(auto& [col, rows] : nodes) {\n        vector<int> column;\n        for(auto& [row, vals] : rows)\n            for(int val : vals)\n                column.push_back(val);\n        result.push_back(column);\n    }\n    return result;\n}\n"
    },
    "flatten_binary_tree": {
      "id": "flatten_binary_tree",
      "title": "Flatten Binary Tree to Linked List",
      "difficulty": "medium",
      "description": "Flatten binary tree to linked list in-place using Morris traversal approach.",
      "input_format": "Binary tree root",
      "output_format": "Flattened tree (right skewed)",
      "constraints": [
        "Number of nodes: [0, 2000]",
        "-100 ≤ Node.val ≤ 100"
      ],
      "example": {
        "input": "root = [1,2,5,3,4,null,6]",
        "output": "[1,null,2,null,3,null,4,null,5,null,6]",
        "explanation": "Tree flattened to right-skewed list"
      },
      "solution_approach": "For each node with left subtree, find rightmost node of left subtree and connect to current right. Move left to right.",
      "related_concepts": [
        "morris_traversal",
        "tree_modification"
      ],
      "cpp_solution": "\nvoid flatten(TreeNode* root) {\n    TreeNode* curr = root;\n    while(curr) {\n        if(curr->left) {\n            TreeNode* rightmost = curr->left;\n            while(rightmost->right) rightmost = rightmost->right;\n            rightmost->right = curr->right;\n            curr->right = curr->left;\n            curr->left = nullptr;\n        }\n        curr = curr->right;\n    }\n}\n"
    },
    "sum_root_to_leaf": {
      "id": "sum_root_to_leaf",
      "title": "Sum Root to Leaf Numbers",
      "difficulty": "easy",
      "description": "Calculate sum of all root-to-leaf path numbers using DFS path accumulation.",
      "input_format": "Binary tree root",
      "output_format": "Integer sum of all path numbers",
      "constraints": [
        "Number of nodes: [1, 1000]",
        "0 ≤ Node.val ≤ 9"
      ],
      "example": {
        "input": "root = [1,2,3]",
        "output": "25",
        "explanation": "Path 1->2 gives 12, path 1->3 gives 13. Sum = 25"
      },
      "solution_approach": "DFS tracking current path number. At leaf, add to total sum.",
      "related_concepts": [
        "dfs",
        "path_accumulation"
      ],
      "cpp_solution": "\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        return dfs(root, 0);\n    }\n    \n    int dfs(TreeNode* root, int currentSum) {\n        if(!root) return 0;\n        currentSum = currentSum * 10 + root->val;\n        if(!root->left && !root->right) return currentSum;\n        return dfs(root->left, currentSum) + dfs(root->right, currentSum);\n    }\n};\n"
    },
    "trie_autocomplete": {
      "id": "trie_autocomplete",
      "title": "Trie Autocomplete System",
      "difficulty": "medium",
      "description": "Implement autocomplete system using Trie with prefix traversal for suggestions.",
      "input_format": "Dictionary words and query prefix",
      "output_format": "List of autocomplete suggestions",
      "constraints": [
        "1 ≤ words.length ≤ 1000",
        "1 ≤ words[i].length ≤ 100"
      ],
      "example": {
        "input": "words = [\"apple\", \"app\", \"application\"], prefix = \"app\"",
        "output": "[\"app\", \"apple\", \"application\"]",
        "explanation": "All words with prefix 'app'"
      },
      "solution_approach": "Build Trie from dictionary. For query, navigate to prefix node and collect all words in subtree.",
      "related_concepts": [
        "trie",
        "prefix_search"
      ],
      "cpp_solution": "\nstruct TrieNode {\n    bool isEnd;\n    TrieNode* children[26];\n    TrieNode() : isEnd(false) { fill(children, children+26, nullptr); }\n};\n\nclass Trie {\n    TrieNode* root;\n    \n    void dfs(TrieNode* node, string& prefix, vector<string>& result) {\n        if(node->isEnd) result.push_back(prefix);\n        for(int i=0; i<26; i++) {\n            if(node->children[i]) {\n                prefix.push_back('a' + i);\n                dfs(node->children[i], prefix, result);\n                prefix.pop_back();\n            }\n        }\n    }\n    \npublic:\n    Trie() { root = new TrieNode(); }\n    \n    void insert(string word) {\n        TrieNode* curr = root;\n        for(char c : word) {\n            int idx = c - 'a';\n            if(!curr->children[idx]) curr->children[idx] = new TrieNode();\n            curr = curr->children[idx];\n        }\n        curr->isEnd = true;\n    }\n    \n    vector<string> autocomplete(string prefix) {\n        TrieNode* curr = root;\n        for(char c : prefix) {\n            int idx = c - 'a';\n            if(!curr->children[idx]) return {};\n            curr = curr->children[idx];\n        }\n        vector<string> result;\n        string temp = prefix;\n        dfs(curr, temp, result);\n        return result;\n    }\n};\n"
    },
    "delete_node_bst": {
      "id": "delete_node_bst",
      "title": "Delete Node in BST",
      "difficulty": "medium",
      "description": "Delete node from BST handling all three deletion cases while maintaining BST properties.",
      "input_format": "BST root and key to delete",
      "output_format": "Root of modified BST",
      "constraints": [
        "Number of nodes: [0, 10^4]",
        "-10^5 ≤ Node.val ≤ 10^5"
      ],
      "example": {
        "input": "root = [5,3,6,2,4,null,7], key = 3",
        "output": "[5,4,6,2,null,null,7]",
        "explanation": "Node 3 deleted, replaced by inorder successor 4"
      },
      "solution_approach": "Three cases: 1) Leaf node - remove directly 2) One child - replace with child 3) Two children - replace with inorder successor",
      "related_concepts": [
        "bst_deletion",
        "inorder_successor"
      ],
      "cpp_solution": "\nTreeNode* deleteNode(TreeNode* root, int key) {\n    if(!root) return nullptr;\n    if(key < root->val) root->left = deleteNode(root->left, key);\n    else if(key > root->val) root->right = deleteNode(root->right, key);\n    else {\n        if(!root->left) return root->right;\n        if(!root->right) return root->left;\n        TreeNode* minNode = root->right;\n        while(minNode->left) minNode = minNode->left;\n        root->val = minNode->val;\n        root->right = deleteNode(root->right, minNode->val);\n    }\n    return root;\n}\n"
    },
    "house_robber_tree": {
      "id": "house_robber_tree",
      "title": "House Robber III",
      "difficulty": "medium",
      "description": "Find maximum money to rob from binary tree houses without robbing adjacent nodes using tree DP.",
      "input_format": "Binary tree root with house values",
      "output_format": "Integer maximum money",
      "constraints": [
        "Number of nodes: [1, 10^4]",
        "0 ≤ Node.val ≤ 10^4"
      ],
      "example": {
        "input": "root = [3,2,3,null,3,null,1]",
        "output": "7",
        "explanation": "Rob houses 3 + 3 + 1 = 7"
      },
      "solution_approach": "DP on tree: for each node, return pair [rob_current, skip_current]. Rob current = node.val + skip_children. Skip current = max(rob_children, skip_children).",
      "related_concepts": [
        "tree_dp",
        "state_optimization"
      ],
      "cpp_solution": "\nclass Solution {\npublic:\n    int rob(TreeNode* root) {\n        auto result = dfs(root);\n        return max(result.first, result.second);\n    }\n    \n    pair<int,int> dfs(TreeNode* root) {\n        if(!root) return {0, 0};\n        auto left = dfs(root->left);\n        auto right = dfs(root->right);\n        int rob = root->val + left.second + right.second;\n        int notRob = max(left.first, left.second) + max(right.first, right.second);\n        return {rob, notRob};\n    }\n};\n"
    },
    "nary_tree_level_order": {
      "id": "nary_tree_level_order",
      "title": "N-ary Tree Level Order Traversal",
      "difficulty": "medium",
      "description": "Perform level order traversal of n-ary tree using BFS adaptation.",
      "input_format": "N-ary tree root",
      "output_format": "2D array of level-wise node values",
      "constraints": [
        "Number of nodes: [0, 10^4]",
        "0 ≤ Node.val ≤ 10^4"
      ],
      "example": {
        "input": "root = [1,null,3,2,4,null,5,6]",
        "output": "[[1],[3,2,4],[5,6]]",
        "explanation": "Level-wise grouping of n-ary tree"
      },
      "solution_approach": "Standard BFS with queue, process level by level using queue size.",
      "related_concepts": [
        "bfs",
        "level_traversal"
      ],
      "cpp_solution": "\nstruct Node {\n    int val;\n    vector<Node*> children;\n    Node(int x) : val(x) {}\n};\n\nvector<vector<int>> levelOrder(Node* root) {\n    if(!root) return {};\n    vector<vector<int>> result;\n    queue<Node*> q;\n    q.push(root);\n    \n    while(!q.empty()) {\n        int size = q.size();\n        vector<int> level;\n        for(int i=0; i<size; i++) {\n            Node* node = q.front();\n            q.pop();\n            level.push_back(node->val);\n            for(Node* child : node->children)\n                q.push(child);\n        }\n        result.push_back(level);\n    }\n    return result;\n}\n"
    },
    "inorder_successor": {
      "id": "inorder_successor",
      "title": "Inorder Successor in BST",
      "difficulty": "medium",
      "description": "Find inorder successor of given node in BST using BST property optimization.",
      "input_format": "BST root and target node p",
      "output_format": "Successor TreeNode or null",
      "constraints": [
        "Number of nodes: [1, 10^4]",
        "-10^5 ≤ Node.val ≤ 10^5"
      ],
      "example": {
        "input": "root = [2,1,3], p = 1",
        "output": "2",
        "explanation": "Inorder successor of 1 is 2"
      },
      "solution_approach": "If node has right subtree, successor is leftmost in right subtree. Otherwise, successor is first ancestor where node is in left subtree.",
      "related_concepts": [
        "bst_properties",
        "inorder_traversal"
      ],
      "cpp_solution": "\nTreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n    TreeNode* successor = nullptr;\n    while(root) {\n        if(p->val >= root->val)\n            root = root->right;\n        else {\n            successor = root;\n            root = root->left;\n        }\n    }\n    return successor;\n}\n"
  },
  "rotate_array": {
      "id": "rotate_array",
      "title": "Rotate Array",
      "difficulty": "medium",
      "description": "Rotate array to the right by k steps using reversal algorithm for O(1) space complexity.",
      "input_format": "Array of integers nums and integer k",
      "output_format": "Array rotated k steps to the right",
      "constraints": [
        "1 ≤ nums.length ≤ 10^5",
        "-2^31 ≤ nums[i] ≤ 2^31-1",
        "0 ≤ k ≤ 10^5"
      ],
      "example": {
        "input": "nums = [1,2,3,4,5,6,7], k = 3",
        "output": "[5,6,7,1,2,3,4]",
        "explanation": "Rotate right by 3 steps: [7,1,2,3,4,5,6] → [6,7,1,2,3,4,5] → [5,6,7,1,2,3,4]"
      },
      "solution_approach": "Three reversals: 1) Reverse entire array 2) Reverse first k elements 3) Reverse remaining n-k elements.",
      "related_concepts": [
        "array_reversal",
        "in_place_rotation"
      ],
      "cpp_solution": "\nvoid rotate(vector<int>& nums, int k) {\n    int n = nums.size();\n    k %= n;\n    \n    auto reverse = [&](int start, int end) {\n        while(start < end) {\n            swap(nums[start++], nums[end--]);\n        }\n    };\n    \n    reverse(0, n-1);\n    reverse(0, k-1);\n    reverse(k, n-1);\n}\n"
    },
    "container_most_water": {
      "id": "container_most_water",
      "title": "Container With Most Water",
      "difficulty": "medium",
      "description": "Find two lines that together with x-axis forms container holding most water using two-pointer technique.",
      "input_format": "Array of integers height",
      "output_format": "Integer maximum area",
      "constraints": [
        "n == height.length",
        "2 ≤ n ≤ 10^5",
        "0 ≤ height[i] ≤ 10^4"
      ],
      "example": {
        "input": "[1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "Lines at index 1 and 8 form container with area 7 × (8-1) = 49"
      },
      "solution_approach": "Two pointers from ends. Move pointer with smaller height inward since moving larger height won't increase area.",
      "related_concepts": [
        "two_pointers",
        "greedy_optimization"
      ],
      "cpp_solution": "\nint maxArea(vector<int>& height) {\n    int left = 0, right = height.size()-1;\n    int maxWater = 0;\n    \n    while(left < right) {\n        int area = min(height[left], height[right]) * (right - left);\n        maxWater = max(maxWater, area);\n        \n        if(height[left] < height[right]) left++;\n        else right--;\n    }\n    return maxWater;\n}\n"
    },
    "trapping_rain_water": {
      "id": "trapping_rain_water",
      "title": "Trapping Rain Water",
      "difficulty": "hard",
      "description": "Calculate how much water can be trapped after raining using two pointers or dynamic programming.",
      "input_format": "Array of integers height",
      "output_format": "Integer total trapped water",
      "constraints": [
        "n == height.length",
        "1 ≤ n ≤ 2*10^4",
        "0 ≤ height[i] ≤ 3*10^4"
      ],
      "example": {
        "input": "[0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "Water trapped: positions 2,5,6,9 trap 1+1+2+1=6 units"
      },
      "solution_approach": "Two pointers: track left_max and right_max. Water at position = min(left_max, right_max) - height[i].",
      "related_concepts": [
        "two_pointers",
        "water_trapping"
      ],
      "cpp_solution": "\nint trap(vector<int>& height) {\n    int left = 0, right = height.size()-1;\n    int left_max = 0, right_max = 0;\n    int water = 0;\n    \n    while(left < right) {\n        if(height[left] < height[right]) {\n            if(height[left] >= left_max) left_max = height[left];\n            else water += left_max - height[left];\n            left++;\n        } else {\n            if(height[right] >= right_max) right_max = height[right];\n            else water += right_max - height[right];\n            right--;\n        }\n    }\n    return water;\n}\n"
    },
    "product_except_self": {
      "id": "product_except_self",
      "title": "Product of Array Except Self",
      "difficulty": "medium",
      "description": "Return array where answer[i] equals product of all elements except nums[i] using prefix/suffix products.",
      "input_format": "Array of integers nums",
      "output_format": "Array of products",
      "constraints": [
        "2 ≤ nums.length ≤ 10^5",
        "-30 ≤ nums[i] ≤ 30"
      ],
      "example": {
        "input": "[1,2,3,4]",
        "output": "[24,12,8,6]",
        "explanation": "Products: [2×3×4, 1×3×4, 1×2×4, 1×2×3]"
      },
      "solution_approach": "Two passes: first compute left products, then multiply with right products during second pass.",
      "related_concepts": [
        "prefix_product",
        "suffix_product"
      ],
      "cpp_solution": "\nvector<int> productExceptSelf(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> result(n, 1);\n    \n    // Left products\n    for(int i=1; i<n; i++)\n        result[i] = result[i-1] * nums[i-1];\n    \n    // Right products\n    int right = 1;\n    for(int i=n-1; i>=0; i--) {\n        result[i] *= right;\n        right *= nums[i];\n    }\n    return result;\n}\n"
    },
    "find_duplicate_number": {
      "id": "find_duplicate_number",
      "title": "Find the Duplicate Number",
      "difficulty": "medium",
      "description": "Find duplicate number in array of n+1 integers where each integer is in range [1,n] using Floyd's cycle detection.",
      "input_format": "Array of integers nums",
      "output_format": "Integer duplicate number",
      "constraints": [
        "1 ≤ n ≤ 10^5",
        "nums.length == n + 1",
        "1 ≤ nums[i] ≤ n"
      ],
      "example": {
        "input": "[1,3,4,2,2]",
        "output": "2",
        "explanation": "2 appears twice in the array"
      },
      "solution_approach": "Treat array as linked list where nums[i] points to nums[nums[i]]. Use Floyd's algorithm to find cycle entry point.",
      "related_concepts": [
        "floyds_cycle_detection",
        "linked_list_cycle"
      ],
      "cpp_solution": "\nint findDuplicate(vector<int>& nums) {\n    int slow = nums[0], fast = nums[0];\n    \n    // Find intersection point\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while(slow != fast);\n    \n    // Find entrance to cycle\n    slow = nums[0];\n    while(slow != fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n    return slow;\n}\n"
    },
    "missing_number": {
      "id": "missing_number",
      "title": "Missing Number",
      "difficulty": "easy",
      "description": "Find missing number from array containing n distinct numbers in range [0,n] using XOR or mathematical approach.",
      "input_format": "Array of integers nums",
      "output_format": "Integer missing number",
      "constraints": [
        "n == nums.length",
        "1 ≤ n ≤ 10^4",
        "0 ≤ nums[i] ≤ n"
      ],
      "example": {
        "input": "[3,0,1]",
        "output": "2",
        "explanation": "Range [0,3] but 2 is missing"
      },
      "solution_approach": "XOR all array elements with all numbers 0 to n. Missing number will remain as XOR result.",
      "related_concepts": [
        "bit_manipulation",
        "mathematical_sum"
      ],
      "cpp_solution": "\nint missingNumber(vector<int>& nums) {\n    int n = nums.size();\n    int missing = n;\n    for(int i=0; i<n; i++)\n        missing ^= i ^ nums[i];\n    return missing;\n}\n\n// Alternative: Mathematical approach\nint missingNumberMath(vector<int>& nums) {\n    int n = nums.size();\n    int expectedSum = n * (n+1) / 2;\n    int actualSum = accumulate(nums.begin(), nums.end(), 0);\n    return expectedSum - actualSum;\n}\n"
    },
    "maximum_subarray_dc": {
      "id": "maximum_subarray_dc",
      "title": "Maximum Subarray (Divide & Conquer)",
      "difficulty": "medium",
      "description": "Find contiguous subarray with largest sum using divide and conquer approach.",
      "input_format": "Array of integers nums",
      "output_format": "Integer maximum sum",
      "constraints": [
        "1 ≤ nums.length ≤ 10^5",
        "-10^4 ≤ nums[i] ≤ 10^4"
      ],
      "example": {
        "input": "[-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "Subarray [4,-1,2,1] has maximum sum 6"
      },
      "solution_approach": "Divide array into halves. Return maximum of: left max, right max, and cross-boundary max sum.",
      "related_concepts": [
        "divide_and_conquer",
        "subarray_optimization"
      ],
      "cpp_solution": "\nint maxCrossingSum(vector<int>& nums, int left, int mid, int right) {\n    int leftSum = INT_MIN, sum = 0;\n    for(int i=mid; i>=left; i--) {\n        sum += nums[i];\n        leftSum = max(leftSum, sum);\n    }\n    \n    int rightSum = INT_MIN; sum = 0;\n    for(int i=mid+1; i<=right; i++) {\n        sum += nums[i];\n        rightSum = max(rightSum, sum);\n    }\n    return leftSum + rightSum;\n}\n\nint maxSubArrayDC(vector<int>& nums, int left, int right) {\n    if(left == right) return nums[left];\n    int mid = left + (right-left)/2;\n    return max({maxSubArrayDC(nums, left, mid),\n               maxSubArrayDC(nums, mid+1, right),\n               maxCrossingSum(nums, left, mid, right)});\n}\n\nint maxSubArray(vector<int>& nums) {\n    return maxSubArrayDC(nums, 0, nums.size()-1);\n}\n"
    },
    "next_permutation": {
      "id": "next_permutation",
      "title": "Next Permutation",
      "difficulty": "medium",
      "description": "Find lexicographically next permutation in-place. If no next permutation exists, rearrange to smallest permutation.",
      "input_format": "Array of integers nums",
      "output_format": "Next permutation in-place",
      "constraints": [
        "1 ≤ nums.length ≤ 100",
        "0 ≤ nums[i] ≤ 100"
      ],
      "example": {
        "input": "[1,2,3]",
        "output": "[1,3,2]",
        "explanation": "Next permutation of 123 is 132"
      },
      "solution_approach": "1) Find largest i where nums[i] < nums[i+1] 2) Find largest j where nums[i] < nums[j] 3) Swap nums[i], nums[j] 4) Reverse suffix starting at i+1.",
      "related_concepts": [
        "permutation_generation",
        "lexicographical_order"
      ],
      "cpp_solution": "\nvoid nextPermutation(vector<int>& nums) {\n    int n = nums.size(), i = n-2;\n    \n    // Find first decreasing element from right\n    while(i >= 0 && nums[i] >= nums[i+1]) i--;\n    \n    if(i >= 0) {\n        // Find smallest element larger than nums[i]\n        int j = n-1;\n        while(nums[j] <= nums[i]) j--;\n        swap(nums[i], nums[j]);\n    }\n    \n    // Reverse suffix\n    reverse(nums.begin() + i + 1, nums.end());\n}\n"
    },
    "spiral_matrix": {
      "id": "spiral_matrix",
      "title": "Spiral Matrix",
      "difficulty": "medium",
      "description": "Return all elements of matrix in spiral order using layer-by-layer traversal.",
      "input_format": "2D matrix",
      "output_format": "List of elements in spiral order",
      "constraints": [
        "m == matrix.length",
        "n == matrix[i].length",
        "1 ≤ m, n ≤ 10"
      ],
      "example": {
        "input": "[[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[1,2,3,6,9,8,7,4,5]",
        "explanation": "Spiral traversal: right→down→left→up"
      },
      "solution_approach": "Track four boundaries: top, bottom, left, right. Move in spiral direction updating boundaries after each side.",
      "related_concepts": [
        "matrix_traversal",
        "boundary_tracking"
      ],
      "cpp_solution": "\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\n    vector<int> result;\n    int top=0, bottom=matrix.size()-1, left=0, right=matrix[0].size()-1;\n    \n    while(top <= bottom && left <= right) {\n        // Right\n        for(int j=left; j<=right; j++)\n            result.push_back(matrix[top][j]);\n        top++;\n        \n        // Down\n        for(int i=top; i<=bottom; i++)\n            result.push_back(matrix[i][right]);\n        right--;\n        \n        // Left\n        if(top <= bottom) {\n            for(int j=right; j>=left; j--)\n                result.push_back(matrix[bottom][j]);\n            bottom--;\n        }\n        \n        // Up\n        if(left <= right) {\n            for(int i=bottom; i>=top; i--)\n                result.push_back(matrix[i][left]);\n            left++;\n        }\n    }\n    return result;\n}\n"
    },
    "find_all_duplicates": {
      "id": "find_all_duplicates",
      "title": "Find All Duplicates in Array",
      "difficulty": "medium",
      "description": "Find all duplicates in array where 1 ≤ a[i] ≤ n using index marking technique without extra space.",
      "input_format": "Array of integers nums",
      "output_format": "List of duplicate numbers",
      "constraints": [
        "n == nums.length",
        "1 ≤ n ≤ 10^5",
        "1 ≤ nums[i] ≤ n"
      ],
      "example": {
        "input": "[4,3,2,7,8,2,3,1]",
        "output": "[2,3]",
        "explanation": "Numbers 2 and 3 appear twice"
      },
      "solution_approach": "Use array indices as hash map. Mark visited numbers by negating value at index nums[i]-1. If already negative, it's a duplicate.",
      "related_concepts": [
        "index_marking",
        "in_place_detection"
      ],
      "cpp_solution": "\nvector<int> findDuplicates(vector<int>& nums) {\n    vector<int> duplicates;\n    for(int i=0; i<nums.size(); i++) {\n        int index = abs(nums[i]) - 1;\n        if(nums[index] < 0)\n            duplicates.push_back(abs(nums[i]));\n        else\n            nums[index] = -nums[index];\n    }\n    \n    // Restore original array (optional)\n    for(int& num : nums) num = abs(num);\n    \n    return duplicates;\n}\n"
    }
}
